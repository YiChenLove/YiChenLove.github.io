[{"content":"Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。 android build.gradle各个配置参数的含义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161  //声明是Android程序  apply plugin: \u0026#39;com.android.application\u0026#39; android { //程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关  lintOptions { abortOnError false //即使报错也不会停止打包  checkReleaseBuilds false //打包release版本的时候进行检测  } compileSdkVersion 23 //编译sdk的版本，也就是API Level，例如API-19、API-20、API-21等等。  buildToolsVersion \u0026#39;23.0.2\u0026#39; //build tools的版本，其中包括了打包工具aapt、dx等等。  //这个工具的目录位于你的sdk目录/build-tools/下  aaptOptions.cruncherEnabled = false aaptOptions.useNewCruncher = false //关闭Android Studio的PNG合法性检查的  defaultConfig { applicationId \u0026#34;com.xiaopao.activity\u0026#34; //应用包名  minSdkVersion 15 //最小sdk版本，如果设备小于这个版本或者大于  //maxSdkVersion(一般不用)将无法安装这个应用  targetSdkVersion 22 //目标sdk版本，如果设备等于这个版本那么android平台  //就不进行兼容性检查，运行效率会高一点  versionCode 15 //版本更新了几次，第一版应用是1，以后每更新一次加1  versionName \u0026#39;1.411\u0026#39; //版本信息，这个会显示给用户，就是用户看到的版本号  archivesBaseName = \u0026#34;weshare-$versionName\u0026#34; //指定打包成Jar文件时候的文件名称  ndk { moduleName \u0026#34;xiaopaowifisafe\u0026#34; //设置库(so)文件名称  ldLibs \u0026#34;log\u0026#34;, \u0026#34;z\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;jnigraphics\u0026#34;, \u0026#34;android\u0026#34; //引入库，比如要用到的__android_log_print  abiFilters \u0026#34;armeabi\u0026#34;, \u0026#34;x86\u0026#34;, \u0026#34;armeabi-v7a\u0026#34; //, \u0026#34;x86\u0026#34; 显示指定支持的ABIs  cFlags \u0026#34;-std=c++11 -fexceptions\u0026#34; // C++11  stl \u0026#34;gnustl_static\u0026#34; } multiDexEnabled true //当方法数超过65535(方法的索引使用的是一个short值，  //而short最大值是65535)的时候允许打包成多个dex文件，动态加载dex。这里面坑很深啊  } //默认的一些文件路径的配置  sourceSets { main { assets.srcDirs = [\u0026#39;assets\u0026#39;] //资源文件  jni.srcDirs \u0026#39;src/main/jni\u0026#39; //jni文件  jniLibs.srcDir \u0026#39;src/main/jniLibs\u0026#39; //jni库  } } //multiDex的一些相关配置，这样配置可以让你的编译速度更快  dexOptions { preDexLibraries = false //让它不要对Lib做preDexing  incremental true //开启incremental dexing,优化编译效率，这个功能android studio默认是关闭的。  javaMaxHeapSize \u0026#34;4g\u0026#34; //增加java堆内存大小  } buildTypes { release { //release版本的配置  zipAlignEnabled true //是否支持zip  shrinkResources true // 移除无用的resource文件  minifyEnabled true //是否进行混淆  proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; //release的Proguard默认为Module下的proguard-rules.pro文件.  debuggable false //是否支持调试  //ndk的一些配置  ndk { // cFlags \u0026#34;-std=c++11 -fexceptions -O3 -D__RELEASE__\u0026#34; // C++11  // platformVersion = \u0026#34;19\u0026#34;  moduleName \u0026#34;xiaopaowifisafe\u0026#34; //设置库(so)文件名称  ldLibs \u0026#34;log\u0026#34;, \u0026#34;z\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;jnigraphics\u0026#34;, \u0026#34;android\u0026#34; //引入库，比如要用到的__android_log_print  abiFilters \u0026#34;armeabi\u0026#34;, \u0026#34;x86\u0026#34;, \u0026#34;armeabi-v7a\u0026#34;//, \u0026#34;x86\u0026#34;  cFlags \u0026#34;-std=c++11 -fexceptions\u0026#34; // C++11  stl \u0026#34;gnustl_static\u0026#34; } //采用动态替换字符串的方式生成不同的release.apk  applicationVariants.all { variant -\u0026gt; variant.outputs.each { output -\u0026gt; def outputFile = output.outputFile if (outputFile != null \u0026amp;\u0026amp; outputFile.name.endsWith(\u0026#39;release.apk\u0026#39;)) { def timeStamp = new Date().format(\u0026#39;yyyyMMddHH\u0026#39;); def fileName = \u0026#34;WeShare-${defaultConfig.versionName}\u0026#34; + \u0026#34;-\u0026#34; + timeStamp + \u0026#34;-lj-\u0026#34; + \u0026#34;.apk\u0026#34;; output.outputFile = file(\u0026#34;${outputFile.parent}/${fileName}\u0026#34;) } } } jniDebuggable false //关闭jni调试  } debug {//debug版本的配置  minifyEnabled false zipAlignEnabled true shrinkResources true // 移除无用的resource文件  proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; debuggable true // jniDebuggable true  ndk { cFlags \u0026#34;-std=c++11 -fexceptions -g -D __DEBUG__\u0026#34; // C++11  } jniDebuggable true } } compileOptions { //在这里你可以进行 Java 的版本配置，  //以便使用对应版本的一些新特性  } productFlavors { //在这里你可以设置你的产品发布的一些东西，  //比如你现在一共软件需要发布到不同渠道，  //且不同渠道中的包名不同，那么可以在此进行配置；  //甚至可以设置不同的 AndroidManifest.xml 文件。  xiaopao { } googlePlay { } solo { } } productFlavors.all { flavor -\u0026gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } //所谓ProductFlavors其实就是可定义的产品特性，  //配合 manifest merger 使用的时候就可以达成在一次编译  //过程中产生多个具有自己特性配置的版本。  //上面这个配置的作用就是，为每个渠道包产生不同的 UMENG_CHANNEL_VALUE 的值。 } //一些依赖的框架 dependencies { compile \u0026#39;com.jakewharton:butterknife:7.0.1\u0026#39; compile \u0026#39;com.android.support:appcompat-v7:23.4.0\u0026#39; compile \u0026#39;com.android.support:support-v4:23.4.0\u0026#39; compile \u0026#39;com.github.pwittchen:reactivenetwork:0.1.3\u0026#39; compile \u0026#39;de.hdodenhof:circleimageview:2.0.0\u0026#39; compile \u0026#39;com.android.support:design:23.4.0\u0026#39; compile \u0026#39;pl.tajchert:waitingdots:0.2.0\u0026#39; } //声明是要使用谷歌服务框架 apply plugin: \u0026#39;com.google.gms.google-services\u0026#39; //第三方依赖库的本地缓存路径 task showMeCache \u0026lt;\u0026lt; { configurations.compile.each { println it } } //使用maven仓库。android有两个标准的library文件服务器，一个jcenter一个maven。两者毫无关系。 //jcenter有的maven可能没有，反之亦然。 //如果要使用jcenter的话就把mavenCentral()替换成jcenter() repositories { mavenCentral() }   ","description":"","id":2,"section":"posts","tags":["android"],"title":"build.gradle配置参数","uri":"https://yichenlove.github.io/posts/android-gardle/"},{"content":" 生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。\n  一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。\n  androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。\n 注意：如需将 androidx.lifecycle导入 Android 项目，请参阅 Lifecycle 版本说明中关于声明依赖项的说明。\n 在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 工作原理的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄漏甚至应用崩溃。\n  假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示：\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class MyLocationListener { public MyLocationListener(Context context, Callback callback) { // ...  } void start() { // connect to system location service  } void stop() { // disconnect from system location service  } } class MyActivity extends AppCompatActivity { private MyLocationListener myLocationListener; @Override public void onCreate(...) { myLocationListener = new MyLocationListener(this, (location) -\u0026gt; { // update UI  }); } @Override public void onStart() { super.onStart(); myLocationListener.start(); // manage other components that need to respond  // to the activity lifecycle  } @Override public void onStop() { super.onStop(); myLocationListener.stop(); // manage other components that need to respond  // to the activity lifecycle  } }    虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 onStart() 和 onStop()）中放置大量的代码，这使得它们难以维护。\n  此外，无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 onStart() 中的某种配置检查）时尤其如此。这可能会导致出现一种竞态条件，在这种条件下，onStop() 方法会在 onStart() 之前结束，这使得组件留存的时间比所需的时间要长。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class MyActivity extends AppCompatActivity { private MyLocationListener myLocationListener; public void onCreate(...) { myLocationListener = new MyLocationListener(this, location -\u0026gt; { // update UI  }); } @Override public void onStart() { super.onStart(); Util.checkUserStatus(result -\u0026gt; { // what if this callback is invoked AFTER activity is stopped?  if (result) { myLocationListener.start(); } }); } @Override public void onStop() { super.onStop(); myLocationListener.stop(); } }    androidx.lifecycle 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。\n Lifecycle  Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。\n  Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：\n 事件\n从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。\n状态\n由 Lifecycle 对象跟踪的组件的当前状态。\n图 1. 构成 Android Activity 生命周期的状态和事件\n 您可以将状态看作图中的节点，将事件看作这些节点之间的边。\n  类可以通过实现 DefaultLifecycleObserver并替换相应的方法（如 onCreate 和 onStart 等）来监控组件的生命周期状态。然后，您可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察器的实例来添加观察器，如下例所示：\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class MyObserver implements DefaultLifecycleObserver { @Override public void onResume(LifecycleOwner owner) { connect() } @Override public void onPause(LifecycleOwner owner) { disconnect() } } myLifecycleOwner.getLifecycle().addObserver(new MyObserver());    在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口，我们将在接下来的部分中对该接口进行说明。\n LifecycleOwner  LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner\n 。\n 此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。\n  实现DefaultLifecycleObserver的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。\n  对于位置跟踪示例，我们可以让 MyLocationListener 类实现 DefaultLifecycleObserver，然后在 onCreate() 方法中使用 Activity 的 Lifecycle 对其进行初始化。这样，MyLocationListener 类便可以自给自足，这意味着，对生命周期状态的变化做出响应的逻辑会在 MyLocationListener（而不是在 Activity）中进行声明。让各个组件存储自己的逻辑可使 Activity 和 Fragment 逻辑更易于管理。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class MyActivity extends AppCompatActivity { private MyLocationListener myLocationListener; public void onCreate(...) { myLocationListener = new MyLocationListener(this, getLifecycle(), location -\u0026gt; { // update UI  }); Util.checkUserStatus(result -\u0026gt; { if (result) { myLocationListener.enable(); } }); } }    一个常见的用例是，如果 Lifecycle 现在未处于良好的状态，则应避免调用某些回调。例如，如果回调在 Activity 状态保存后运行 Fragment 事务，就会触发崩溃，因此我们绝不能调用该回调。\n  为简化此使用场景，Lifecycle 类允许其他对象查询当前状态。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class MyLocationListener implements DefaultLifecycleObserver { private boolean enabled = false; public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) { ... } @Override public void onStart(LifecycleOwner owner) { if (enabled) { // connect  } } public void enable() { enabled = true; if (lifecycle.getCurrentState().isAtLeast(STARTED)) { // connect if not connected  } } @Override public void onStop(LifecycleOwner owner) { // disconnect if connected  } }    对于此实现，LocationListener 类可以完全感知生命周期。如果我们需要从另一个 Activity 或 Fragment 使用 LocationListener，只需对其进行初始化。所有设置和拆解操作都由类本身管理。\n  如果库提供了需要使用 Android 生命周期的类，我们建议您使用生命周期感知型组件。库客户端可以轻松集成这些组件，而无需在客户端进行手动生命周期管理。\n 实现自定义 LifecycleOwner  支持库 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。\n  如果您有一个自定义类并希望使其成为 LifecycleOwner，您可以使用 LifecycleRegistry 类，但需要将事件转发到该类，如以下代码示例中所示：\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class MyActivity extends Activity implements LifecycleOwner { private LifecycleRegistry lifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); lifecycleRegistry = new LifecycleRegistry(this); lifecycleRegistry.markState(Lifecycle.State.CREATED); } @Override public void onStart() { super.onStart(); lifecycleRegistry.markState(Lifecycle.State.STARTED); } @NonNull @Override public Lifecycle getLifecycle() { return lifecycleRegistry; } }   生命周期感知型组件的最佳做法  使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 ViewModel 执行此操作，并观察 LiveData 对象以将更改体现到视图中。 设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 ViewModel。 将数据逻辑放在 ViewModel 类中。ViewModel 应充当界面控制器与应用其余部分之间的连接器。不过要注意，ViewModel 不负责获取数据（例如，从网络获取）。但是，ViewModel 应调用相应的组件来获取数据，然后将结果提供给界面控制器。 使用数据绑定在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 Butter Knife 之类的库，以避免样板代码并实现更好的抽象化。 如果界面很复杂，不妨考虑创建 presenter 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。 避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄漏并且不会获得垃圾回收器的妥善处置。 使用 Kotlin 协程管理长时间运行的任务和其他可以异步运行的操作。  生命周期感知型组件的用例  生命周期感知型组件可使您在各种情况下更轻松地管理生命周期。下面列举几个例子：\n  在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。借助生命周期感知型组件 LiveData，应用可以在用户使用位置发生变化时自动更新界面。 停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，您还可以使用生命周期感知型组件终止缓冲。 开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。 暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。  处理 ON_STOP 事件  如果 Lifecycle 属于 AppCompatActivity 或 Fragment，那么调用 AppCompatActivity 或 Fragment 的 onSaveInstanceState()时，Lifecycle 的状态会更改为 CREATED 并且会分派 ON_STOP 事件。\n  通过 onSaveInstanceState()保存 Fragment 或 AppCompatActivity 的状态后，其界面被视为不可变，直到调用 ON_START。如果在保存状态后尝试修改界面，很可能会导致应用的导航状态不一致，因此应用在保存状态后运行 FragmentTransaction 时，FragmentManager 会抛出异常。如需了解详情，请参阅 commit()。\n  LiveData 本身可防止出现这种极端情况，方法是在其观察者的关联 Lifecycle 还没有至少处于 STARTED 状态时避免调用其观察者。在后台，它会在决定调用其观察者之前调用 isAtLeast()。\n  遗憾的是，AppCompatActivity 的 onStop() 方法会在 onSaveInstanceState()之后调用，这样就会留下一个缺口，即不允许界面状态发生变化，但 Lifecycle 尚未移至 CREATED 状态。\n  为防止出现这个问题，beta2 及更低版本中的 Lifecycle 类会将状态标记为 CREATED 而不分派事件，这样一来，即使未分派事件（直到系统调用 onStop()），检查当前状态的代码也会获得实际值。\n  遗憾的是，此解决方案有两个主要问题：\n  在 API 23 及更低级别，Android 系统实际上会保存 Activity 的状态，即使它的一部分被另一个 Activity 覆盖。换句话说，Android 系统会调用onSaveInstanceState()，但不一定会调用 onStop()。这样可能会产生很长的时间间隔，在此时间间隔内，观察者仍认为生命周期处于活动状态，虽然无法修改其界面状态。 任何要向 LiveData 类公开类似行为的类都必须实现由 Lifecycle 版本 beta 2 及更低版本提供的解决方案。  注意：为了简化此流程并让其与较低版本实现更好的兼容性，自 1.0.0-rc1 版本起，当调用 onSaveInstanceState()时，会将 Lifecycle 对象标记为 CREATED 并分派 ON_STOP，而不等待调用 onStop() 方法。这不太可能影响您的代码，但您需要注意这一点，因为它与 API 26 及更低级别的 Activity 类中的调用顺序不符。\n","description":"","id":3,"section":"posts","tags":["android"],"title":"Android 生命周期","uri":"https://yichenlove.github.io/posts/android-lifecrcle/"},{"content":"一、cookie 简介 由于HTTP协议的无状态，客户端经常使用cookie来提供跨URL请求的数据持久存储。URL加载系统提供了创建和管理cookie的接口，作为HTTP请求的一部分发送cookies，并在Web服务器的响应时接收cookie。等多cookie信息请前往百度百科cookie\n二、使用cookie 首先，正常业务场景下，cookie最先是由服务器生成好\n然后客服端请求接口，获取到cookie，将cookie存储起来。\n最后，在每次网络请求的时候附带cookie\n但是在iOS网络请求中使用cookie还有1个条件，那就是在iOS中网络请求类NSURLRequest中设置是否要使用cookie\n1 2 3 4  /*! 决定这个请求是否要使用cookie，默认为YES */ @property BOOL HTTPShouldHandleCookies;   iOS 中cookie是一个NSHTTPCookie对象,它包含了各种各样的属性(properties)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // cookie 版本 // 版本0：此版本是指由Netscape定义的原始cookie格式的“传统”或“旧式”cookie。遇到的大多数Cookie都是这种格式。 // 版本1：此版本是指RFC 2965（HTTP状态管理机制）中定义的Cookie。 @property (readonly) NSUInteger version; // cookie存储信息的名字，比如：token @property (readonly, copy) NSString *name; // cookie存储的信息，比如：8d2je219jjd0120d12e1212e12(token的值) @property (readonly, copy) NSString *value; // cookie有效期（过期，NSHTTPCookieStorage会自动删除存储的cookie） @property (nullable, readonly, copy) NSDate *expiresDate; // 是否应在会话结束时被丢弃（不管过期日期如何） @property (readonly, getter=isSessionOnly) BOOL sessionOnly; // cookie的域名 @property (readonly, copy) NSString *domain; // 路径 @property (readonly, copy) NSString *path; // 该cookie是否应该仅通过安全通道发送 @property (readonly, getter=isSecure) BOOL secure; // 是否应仅根据RFC 2965发送到HTTP服务器 @property (readonly, getter=isHTTPOnly) BOOL HTTPOnly; // 端口列表 @property (nullable, readonly, copy) NSArray\u0026lt;NSNumber *\u0026gt; *portList;   三、接收cookie 假设当前有这么一个场景，客服端中用户在登录时服务器将当前用户的token等相关信息存在cookie中返回给客户端，客户端在每次请求其他数据时都需要将此cookie信息(保存的用户信息)携带，以便区分当前是哪个用户。\n那么我们要如何接收这个cookie呢,iOS中提供了NSHTTPCookieStorage这个类，来存储服务器给我们发送的cookie,NSURLResponse根据会当前的NSHTTPCookieStorage接受策略自动接收返回的cookie并存储在NSHTTPCookieStorage中，我们不需要做任何操作，在我们发送请求是，我们只需要设置HTTPShouldHandleCookies为YES（默认为YES）, NSURLRequest会自动附带cookie的信息发送给服务器。以下是三种接收策略：\n1 2 3 4 5 6 7 8 9  typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) { // 永远接收Cookie，这种情况下，NSHTTPCookieStorage会将接收到的cookie 存储在偏好设置中  NSHTTPCookieAcceptPolicyAlways, // 永远不接受Cookie，这种情况下，NSHTTPCookieStorage不会存储cookie到本地  NSHTTPCookieAcceptPolicyNever, // 只接收指定域名的Cookie  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain };   NSHTPCookieStorage对象是一个单例对象，它管理着所有的cookie，它提供了一些方法来允许客户端设置和移除cookie，和获取当前cookie的设置。\n通过单例获取NSHTTPCookieStorage对象\n1 2  NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];   NSHTPCookieStorage 设置、删除、获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // cookie的接收策略 @property NSHTTPCookieAcceptPolicy cookieAcceptPolicy // 获取NSHTTPCookieStorage存储的所有cookie @property (nullable , readonly, copy) NSArray\u0026lt;NSHTTPCookie *\u0026gt; *cookies // 设置cookie - (void)setCookie:(NSHTTPCookie *)cookie // 删除cookie - (void)deleteCookie:(NSHTTPCookie *)cookie // 在某个时间点删除cookies - (void)removeCookiesSinceDate:(NSDate *)date // 获取指定URL的cookies - (nullable NSArray\u0026lt;NSHTTPCookie *\u0026gt; *)cookiesForURL:(NSURL *)URL // 获取指定域名指定URL的cookies - (void)setCookies:(NSArray\u0026lt;NSHTTPCookie *\u0026gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL   四、清除cookie 还有一个场景需要清除cookie,那就是在客户端，用户退出登录，我们就需要删除NSHTPCookieStorage中的cookie\n1 2 3 4  NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]; for (NSHTTPCookie *cookie in cookies) { [[NSHTTPCookieStorage sharedHTTPCookieStorage] deleteCookie:cookie]; }   五、总结 总体来说，使用cookie我们要确认三步信息：\n1.NSURLRequest是否允许使用cookie(HTTPShouldHandleCookies),默认允许。\n2.NSHTTPCookieStorage的接收策略\n3.退出时清除NSHTTPCookieStorage存储的cookie\n","description":"","id":4,"section":"posts","tags":["ios","cookie"],"title":"iOS 网络编程之 NSHTTPCookie/NSHTTPCookieStorage","uri":"https://yichenlove.github.io/posts/ios-cookie/"},{"content":"常常可以看到，很多Android应用都有这么一个功能，就是滑动关闭Activity，比如微信，CSDN移动端，百度贴吧移动端等。我自己也想写个滑动关闭Activity，最近事情没有那么多，我就google了一下，查看了一下实现滑动关闭Activity的实现方法，其中，有个思路，我觉得很不错，因此，在这里，我通过别人的思路，自己实现了一下滑动关闭Activity的方法，在此记录一下。我希望这篇博客，能给人有所启发，也希望大家能对我有所批判，如有更好的方式，请给我留言，不甚感激。\n首先我们先看下实现效果：\n 要写滑动关闭Activity，有几个问题要解决：\n1.透明的显示底层的Activity。\n2.边界检测，滑动视图，以及自动滚动。\n3.阴影绘制。\n一、透明的显示底层Activity，可以使用透明主题，也可以使用其他主题，但是必须修改主题的几个属性，来达到透明的效果，如：\n1 2 3 4 5  \u0026lt;style name=\u0026#34;AppTheme\u0026#34; parent=\u0026#34;@style/Theme.AppCompat.Light\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@android:color/transparent\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowAnimationStyle\u0026#34;\u0026gt;@android:style/Animation.Translucent\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt;   二、谷歌在V4包中，增加ViewDragHelper类，这个类能够对滑动，边界检测，自动滚动等功能，提供了很好的实现。因此在这里我们选择ViewDragHelper来实现滑动功能。\n三、阴影绘制，Paint画笔来绘制。我们选择在dispatchDraw（）方法中绘制，为什么不用onDraw()，因为onDraw有时候在ViewGroup中不会执行。我们使用画笔的setShader（）,通过写一个LinearGradient(),再绘制一个矩形，得到阴影效果。\n最核心的原理就是在于，替换Window的DecorView下的LinearLayout。下面从代码直观的说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182  package com.mjc.slidebackdemo.view; import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.BitmapShader; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.LinearGradient; import android.graphics.Paint; import android.graphics.RectF; import android.graphics.Shader; import android.support.v4.widget.ViewDragHelper; import android.util.DisplayMetrics; import android.view.MotionEvent; import android.view.View; import android.view.ViewGroup; import android.widget.FrameLayout; import java.util.Map; /** * Created by mjc on 2016/2/26. * 功能：当activity布局中嵌入当前布局，该activity可以从边缘滑动关闭 * 实现原理： * 1.获取DecorView的RootView,删除RootView，把RootView添加到当前View * 再把当前View添加到DecorView */ public class SlideBackLayout extends FrameLayout { /**当前Activity的DecorView*/ private ViewGroup mDecorView; /**DecorView下的LinearLayout*/ private View mRootView; /**需要边缘滑动删除的Activity*/ private Activity mActivity; /**Drag助手类*/ private ViewDragHelper mViewDragHelper; /**触发退出当前Activity的宽度*/ private float mSlideWidth; /**屏幕的宽和高*/ private int mScreenWidth; private int mScreenHeight; /**画笔，用来绘制阴影效果*/ private Paint mPaint; /**用于记录当前滑动距离*/ private int curSlideX; public SlideBackLayout(Context context) { super(context); init(context); } private void init(Context context) { //必须是传入Activity  mActivity = (Activity) context; //构造ViewDragHelper  mViewDragHelper = ViewDragHelper.create(this, new DragCallback()); //设置从左边缘捕捉View  mViewDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT); //初始化画笔  mPaint = new Paint(); mPaint.setStrokeWidth(2); mPaint.setAntiAlias(true); mPaint.setColor(Color.GRAY); } //绑定方法，在Activity的DecorView下插入当前ViewGroup,原来的RootView放于当前ViewGroup下  public void bind() { mDecorView = (ViewGroup) mActivity.getWindow().getDecorView(); mRootView = mDecorView.getChildAt(0); mDecorView.removeView(mRootView); this.addView(mRootView); mDecorView.addView(this); //计算屏幕宽度  DisplayMetrics dm = new DisplayMetrics(); mActivity.getWindowManager().getDefaultDisplay().getMetrics(dm); mScreenWidth = dm.widthPixels; mScreenHeight = dm.heightPixels; mSlideWidth = dm.widthPixels *0.28f; } @Override public boolean onInterceptHoverEvent(MotionEvent event) { return mViewDragHelper.shouldInterceptTouchEvent(event); } @Override public boolean onTouchEvent(MotionEvent event) { mViewDragHelper.processTouchEvent(event); return true; } class DragCallback extends ViewDragHelper.Callback { @Override public boolean tryCaptureView(View child, int pointerId) { return false; } @Override public void onViewReleased(View releasedChild, float xvel, float yvel) { //当前回调，松开手时触发，比较触发条件和当前的滑动距离  int left = releasedChild.getLeft(); if (left \u0026lt;= mSlideWidth) { //缓慢滑动的方法,小于触发条件，滚回去  mViewDragHelper.settleCapturedViewAt(0, 0); } else { //大于触发条件，滚出去...  mViewDragHelper.settleCapturedViewAt(mScreenWidth, 0); } //需要手动调用更新界面的方法  invalidate(); } @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) { curSlideX = left; //当滑动位置改变时，刷新View,绘制新的阴影位置  invalidate(); //当滚动位置到达屏幕最右边，则关掉Activity  if (changedView == mRootView \u0026amp;\u0026amp; left \u0026gt;= mScreenWidth) { mActivity.finish(); } } @Override public int clampViewPositionHorizontal(View child, int left, int dx) { //限制左右拖拽的位移  left = left \u0026gt;= 0 ? left : 0; return left; } @Override public int clampViewPositionVertical(View child, int top, int dy) { //上下不能移动，返回0  return 0; } @Override public void onEdgeDragStarted(int edgeFlags, int pointerId) { //触发边缘时，主动捕捉mRootView  mViewDragHelper.captureChildView(mRootView, pointerId); } } @Override public void computeScroll() { //使用settleCapturedViewAt方法是，必须重写computeScroll方法，传入true  //持续滚动期间，不断刷新ViewGroup  if (mViewDragHelper.continueSettling(true)) invalidate(); } @Override protected void dispatchDraw(Canvas canvas) { //进行阴影绘制,onDraw（）方法在ViewGroup中不一定会执行  drawShadow(canvas); super.dispatchDraw(canvas); } private void drawShadow(Canvas canvas) { canvas.save(); //构造一个渐变  Shader mShader = new LinearGradient(curSlideX - 40, 0, curSlideX, 0, new int[]{Color.parseColor(\u0026#34;#1edddddd\u0026#34;), Color.parseColor(\u0026#34;#6e666666\u0026#34;), Color.parseColor(\u0026#34;#9e666666\u0026#34;)}, null, Shader.TileMode.REPEAT); //设置着色器  mPaint.setShader(mShader); //绘制时，注意向左边偏移  RectF rectF = new RectF(curSlideX - 40, 0, curSlideX, mScreenHeight); canvas.drawRect(rectF, mPaint); canvas.restore(); } }   我在代码中，进行详细的注释。总体来说，不难理解。我们在使用的时候，在布局文件中，一定要在根布局设置背景颜色，否则整个布局将会是透明的。下面是使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package com.mjc.slidebackdemo; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.mjc.slidebackdemo.view.SlideBackLayout; /** * 从左侧边缘向右滑动可以关闭当前页面 */ public class SecondActivity extends AppCompatActivity { private TextView tv; private SlideBackLayout mSlideBackLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mSlideBackLayout = new SlideBackLayout(this); mSlideBackLayout.bind(); tv = (TextView) findViewById(R.id.tv); } }   哪个Activity需要滑动关闭的功能，只需要实例化一个SlideBackLayout对象，并调用bind()方法。这样，我们就实现了滑动关闭的效果了。\n","description":"","id":5,"section":"posts","tags":["android"],"title":"滑动关闭Activity","uri":"https://yichenlove.github.io/posts/android-activity2/"},{"content":" ❝**「前言」**：这里的标题看起来是 \u0026ldquo;高级用法\u0026rdquo;，不少同学可能就表示被劝退了。其实 Typescript 作为一门 强类型 编程语言，最具特色的就是他的类型表达能力，这是很多完备的后端语言都难以媲美的 说的很对，但PHP是最好的语言，所以如果你搞懂了他的类型系统，对将来的日常开发一定是大有裨益的，但过于灵活的类型系统也注定了 Typescript 无法成为一门纯粹的静态语言，不过每一行代码都有代码提示他不香嘛？ ❞\n 基础准备 阅读本文需要具备的基础知识。\n预备知识 本文的定位为理解高级用法，故不会涉及过多基础知识相关的讲解，需要读者自己去完善这方面的知识储备。\n此文档的内容默认要求读者已经具备以下知识：  有 Javascript 或其他语言编程经验。 有 Typescript 实际使用经验，最好在正经项目中完整地使用过。 了解 Typescript 基础语法以及常见关键字地作用。 对 Typescript 的 类型系统 架构有一个最基本的了解。  相关资源推荐  Typescript 官网[1] TypeScript Deep Dive[2] TypeScript GitHub地址[3]  背景 初用 Typescript 开发的同学一定有这样的困扰：\n 代码代码提示并不智能，似乎只能显式的定义类型，才能有代码提示，无法理解这样的编程语言居然有这么多人趋之若鹜。 各种各样的类型报错苦不堪言，本以为听信网上说 Typescript 可以提高代码可维护性，结果却发现徒增了不少开发负担。 显式地定义所有的类型似乎能应付大部分常见，但遇到有些复杂的情况却发现无能为力，只能含恨写下若干的 as any 默默等待代码 review 时的公开处刑。 项目急时间紧却发现 Typescript 成了首要难题，思索片刻决定投靠的 Anyscript，快速开发业务逻辑，待到春暖花开时再回来补充类型。双倍的工作量，双倍的快乐只有自己才懂。  为了避免以上悲剧的发生或者重演，我们只有在对它有更加深刻的理解之后，才能在开发时游刃有余、在撸码时纵横捭阖。\nTypescript 类型系统简述  ❝**「思考题」**：有人说 Typescript = Type + Javascript，那么抛开 Javascript 不谈，这里的 Type 是一门完备的编程语言吗？ ❞\n Typescript 的类型是支持定义 \u0026ldquo;函数定义\u0026rdquo; 的 有过编程经验的同学都知道，函数是一门编程语言中最基础的功能之一，函数是过程化、面向对象、函数式编程中程序封装的基本单元，其重要程度不言而喻。\n函数可以帮助我们做很多事，比如 ：\n 函数可以把程序封装成一个个功能，并形成函数内部的变量作用域，通过静态变量保存函数状态，通过返回值返回结果。 函数可以帮助我们实现过程的复用，如果一段逻辑可以被使用多次，就封装成函数，被其它过程多次调用。 函数也可以帮我们更好地组织代码结构，帮助我们更好地维护代码。  那么言归正传，如何在 Typescript 类型系统中定义函数呢？ Typescript 中类型系统中的的函数被称作 泛型操作符，其定义的简单的方式就是使用 type 关键字：\n1 2  // 这里我们就定义了一个最简单的泛型操作符 type foo\\\u0026lt;T\\\u0026gt; \\= T;   这里的代码如何理解呢，其实这里我把代码转换成大家最熟悉的 Javascript 代码其实就不难理解了：\n1 2 3 4  // 把上面的类型代码转换成 \\`JavaScript\\` 代码 function foo\\(T\\) \\{ return T \\}   那么看到这里有同学心里要犯嘀咕了，心想你这不是忽悠我嘛？这不就是 Typescript 中定义类型的方式嘛？这玩意儿我可太熟了，这玩意儿不就和 interface 一样的嘛，我还知道 Type 关键字和 interface 关键字有啥细微的区别呢！\n嗯，同学你说的太对了，不过你不要着急，接着听我说，其实类型系统中的函数还支持对入参的约束。\n1 2  // 这里我们就对入参 T 进行了类型约束 type foo\\\u0026lt;T extends string\\\u0026gt; \\= T;   那么把这里的代码转换成我们常见的 Typescript 是什么样子的呢？\n1 2 3  function foo\\(T: string\\) \\{ return T \\}   当然啦我们也可以给它设置默认值：\n1 2  // 这里我们就对入参 T 增加了默认值 type foo\\\u0026lt;T extends string \\= \u0026#39;hello world\u0026#39;\\\u0026gt; \\= T;   那么这里的代码转换成我们常见的 Typescript 就是这样的：\n1 2 3  function foo\\(T: string \\= \u0026#39;hello world\u0026#39;\\) \\{ return T \\}   看到这里肯定有同学迫不及待地想要提问了：「那能不能像 JS 里的函数一样支持剩余参数呢？」\n很遗憾，目前暂时是不支持的，但是在我们日常开发中一定是有这样的需求存在的。那就真的没有办法了嘛？其实也不一定，我们可以通过一些骚操作来模拟这种场景，当然这个是后话了，这里就不作拓展了。\nTypescript 的类型是支持 \u0026ldquo;条件判断\u0026rdquo; 的  ❝人生总会面临很多选择，编程也是一样。 ——我瞎编的 ❞\n 条件判断也是编程语言中最基础的功能之一，也是我们日常撸码过程成最常用的功能，无论是 if else 还是 三元运算符，相信大家都有使用过。\n那么在 Typescript 类型系统中的类型判断要怎么实现呢？ 其实这在 Typescript 官方文档被称为 条件类型(Conditional Types)，定义的方法也非常简单，就是使用 extends 关键字。\n1  T extends U \\? X : Y;   这里相信聪明的你一眼就看出来了，这不就是 三元运算符 嘛！是的，而且这和三元运算符的也发也非常像，如果 T extends U 为 true 那么 返回 X ，否则返回 Y。\n结合之前刚刚讲过的 \u0026ldquo;函数\u0026rdquo;，我们就可以简单的拓展一下：\n1 2 3 4 5 6 7  type num \\= 1; type str \\= \u0026#39;hello world\u0026#39;; type IsNumber\\\u0026lt;N\\\u0026gt; \\= N extends number \\? \u0026#39;yes, is a number\u0026#39; : \u0026#39;no, not a number\u0026#39;; type result1 \\= IsNumber\\\u0026lt;num\\\u0026gt;; // \u0026#34;yes, is a number\u0026#34; type result2 \\= IsNumber\\\u0026lt;str\\\u0026gt;; // \u0026#34;no, not a number\u0026#34;   这里我们就实现了一个简单的带判断逻辑的函数。\nTypescript 的类型是支持 \u0026ldquo;数据结构\u0026rdquo; 的 模拟真实数组 看到这里肯定有同学就笑了，这还不简单，就举例来说，Typescript 中最常见数据类型就是 数组（Array） 或者 元组（tuple）。\n同学你说的很对，「那你知道如何对 元组类型 作 push、pop、shift、unshift 这些行为操作吗？」\n其实这些操作都是可以被实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 这里定义一个工具类型，简化代码 type ReplaceValByOwnKey\\\u0026lt;T, S extends any\\\u0026gt; \\= \\{ \\[P in keyof T\\]: S\\[P\\] \\}; // shift action type ShiftAction\\\u0026lt;T extends any\\[\\]\\\u0026gt; \\= \\(\\(...args: T\\) \\=\u0026gt; any\\) extends \\(\\(arg1: any, ...rest: infer R\\) \\=\u0026gt; any\\) \\? R : never; // unshift action type UnshiftAction\\\u0026lt;T extends any\\[\\], A\\\u0026gt; \\= \\(\\(args1: A, ...rest: T\\) \\=\u0026gt; any\\) extends \\(\\(...args: infer R\\) \\=\u0026gt; any\\) \\? R : never; // pop action type PopAction\\\u0026lt;T extends any\\[\\]\\\u0026gt; \\= ReplaceValByOwnKey\\\u0026lt;ShiftAction\\\u0026lt;T\\\u0026gt;, T\\\u0026gt;; // push action type PushAction\\\u0026lt;T extends any\\[\\], E\\\u0026gt; \\= ReplaceValByOwnKey\\\u0026lt;UnshiftAction\\\u0026lt;T, any\\\u0026gt;, T \\\u0026amp; \\{ \\[k: string\\]: E \\}\\\u0026gt;; // test ... type tuple \\= \\[\u0026#39;vue\u0026#39;, \u0026#39;react\u0026#39;, \u0026#39;angular\u0026#39;\\]; type resultWithShiftAction \\= ShiftAction\\\u0026lt;tuple\\\u0026gt;; // \\[\u0026#34;react\u0026#34;, \u0026#34;angular\u0026#34;\\] type resultWithUnshiftAction \\= UnshiftAction\\\u0026lt;tuple, \u0026#39;jquery\u0026#39;\\\u0026gt;; // \\[\u0026#34;jquery\u0026#34;, \u0026#34;vue\u0026#34;, \u0026#34;react\u0026#34;, \u0026#34;angular\u0026#34;\\] type resultWithPopAction \\= PopAction\\\u0026lt;tuple\\\u0026gt;; // \\[\u0026#34;vue\u0026#34;, \u0026#34;react\u0026#34;\\] type resultWithPushAction \\= PushAction\\\u0026lt;tuple, \u0026#39;jquery\u0026#39;\\\u0026gt;; // \\[\u0026#34;vue\u0026#34;, \u0026#34;react\u0026#34;, \u0026#34;angular\u0026#34;, \u0026#34;jquery\u0026#34;\\]    ❝**「注意」**：这里的代码仅用于测试，操作某些复杂类型可能会报错，需要做进一步兼容处理，这里简化了相关代码，请勿用于生产环境！ ❞\n 相信读到这里，大部分同学应该可以已经可以感受到 Typescript 类型系统的强大之处了，其实这里还是继续完善，为元组增加 concat 、map 等数组的常用的功能，这里不作详细探讨，留给同学们自己课后尝试吧。\n但是其实上面提到的 \u0026ldquo;数据类型\u0026rdquo; 并不是我这里想讲解的 \u0026ldquo;数据类型\u0026rdquo;，上述的数据类型本质上还是服务于代码逻辑的数据类型，其实并不是服务于 类型系统 本身的数据类型。\n上面这句话的怎么理解呢？\n不管是 数组 还是 元组，在广义的理解中，其实都是用来对 「数据」 作 「批量操作」，同理，服务于 类型系统 本身的数据结构，应该也可以对 「类型」 作 「批量操作」。\n那么如何对 「类型」 作 「批量操作」 呢？或者说服务于 类型系统 中的 「数组」 是什么呢？\n下面就引出了本小节真正的 \u0026ldquo;数组\u0026rdquo;：联合类型(Union Types)\n说起 联合类型(Union Types) ，相信使用过 Typescript 同学的一定对它又爱又恨：\n 定义函数入参的时候，当同一个位置的参数允许传入多种参数类型，使用 联合类型(Union Types) 会非常的方便，但想智能地推导出返回值的类型地时候却又犯了难。 当函数入参个数不确定地时候，又不愿意写出 (...args: any[]) =\u0026gt; void 这种毫无卵用的参数类型定义。 使用 联合类型(Union Types) 时，虽然有 类型守卫（Type guard），但是某些场景下依然不够好用。  其实当你对它有足够的了解时，你就会发现 联合类型(Union Types) 比 交叉类型(Intersection Types) 不知道高到哪里去了，我和它谈笑风生。\n类型系统中的 \u0026ldquo;数组\u0026rdquo; 下面就让我们更加深入地了解一下 联合类型(Union Types)： 如何遍历 联合类型(Union Types) 呢？ 既然目标是 「批量操作类型」，自然少不了类型的 「遍历」，和大多数编程语言方法一样，在 Typescript 类型系统中也是 in 关键字来遍历。\n1 2 3  type key \\= \u0026#39;vue\u0026#39; | \u0026#39;react\u0026#39;; type MappedType \\= \\{ \\[k in key\\]: string \\} // \\{ vue: string; react: string; \\}   你看，通过 in 关键字，我们可以很容易地遍历 联合类型(Union Types)，并对类型作一些变换操作。\n但有时候并不是所有所有 联合类型(Union Types) 都是我们显式地定义出来的。\n我们想动态地推导出 联合类型(Union Types) 类型有哪些方法呢？ 可以使用 keyof 关键字动态地取出某个键值对类型的 key\n1 2 3 4 5 6 7  interface Student \\{ name: string; age: number; \\} type studentKey \\= keyof Student; // \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34;   同样的我们也可以通过一些方法取出 元组类型 子类型\n1 2 3 4  type framework \\= \\[\u0026#39;vue\u0026#39;, \u0026#39;react\u0026#39;, \u0026#39;angular\u0026#39;\\]; type frameworkVal1 \\= framework\\[number\\]; // \u0026#34;vue\u0026#34; | \u0026#34;react\u0026#34; | \u0026#34;angular\u0026#34; type frameworkVal2 \\= framework\\[any\\]; // \u0026#34;vue\u0026#34; | \u0026#34;react\u0026#34; | \u0026#34;angular\u0026#34;   实战应用 看到这里，有的同学可能要问了，你既然说 联合类型(Union Types) 可以批量操作类型，「那我想把某一组类型批量映射成另一种类型，该怎么操作呢」？\n方法其实有很多，这里提供一种思路，抛砖引玉一下，别的方法就留给同学们自行研究吧。\n其实分析一下上面那个需求，不难看出，这个需求其实和数组的 map 方法有点相似\n那么如何实现一个操作 联合类型(Union Types) 的 map 函数呢？ 1 2  // 这里的 placeholder 可以键入任何你所希望映射成为的类型 type UnionTypesMap\\\u0026lt;T\\\u0026gt; \\= T extends any \\? \u0026#39;placeholder\u0026#39; : never;   其实这里聪明的同学已经看出来，我们只是利用了 条件类型(Conditional Types)，使其的判断条件总是为 true，那么它就总是会返回左边的类型，我们就可以拿到 泛型操作符 的入参并自定义我们的操作。\n让我们趁热打铁，再举个具体的栗子：把 「联合类型(Union Types)」 的每一项映射成某个函数的 「返回值」。\n1 2 3 4 5 6  type UnionTypesMap2Func\\\u0026lt;T\\\u0026gt; \\= T extends any \\? \\(\\) \\=\u0026gt; T : never; type myUnionTypes \\= \u0026#34;vue\u0026#34; | \u0026#34;react\u0026#34; | \u0026#34;angular\u0026#34;; type myUnionTypes2FuncResult \\= UnionTypesMap2Func\\\u0026lt;myUnionTypes\\\u0026gt;; // \\(\\(\\) =\u0026gt; \u0026#34;vue\u0026#34;\\) | \\(\\(\\) =\u0026gt; \u0026#34;react\u0026#34;\\) | \\(\\(\\) =\u0026gt; \u0026#34;angular\u0026#34;\\)   相信有了上述内容的学习，我们已经对 联合类型(Union Types) 有了一个相对全面的了解，后续在此基础之上在作一些高级的拓展，也如砍瓜切菜一般简单了。\n其他数据类型 当然除了数组，还存在其他的数据类型，例如可以用 type 或 interface 模拟 Javascript 中的 「字面量对象」，其特征之一就是可以使用 myType['propKey'] 这样的方式取出子类型。这里抛砖引玉一下，有兴趣的同学可以自行研究。\nTypescript 的类型是支持 \u0026ldquo;作用域\u0026rdquo; 的 全局作用域 就像常见的编程语言一样，在 Typescript 的类型系统中，也是支持 「全局作用域」 的。换句话说，你可以在没有 「导入」 的前提下，在 「任意文件任意位置」 直接获取到并且使用它。\n通常使用 declare 关键字来修饰，例如我们常见的 图片资源 的类型定义：\n1 2 3  declare module \u0026#39;\\*.png\u0026#39;; declare module \u0026#39;\\*.svg\u0026#39;; declare module \u0026#39;\\*.jpg\u0026#39;;   当然我们也可以在 「全局作用域」 内声明一个类型：\n1 2 3 4 5  declare type str \\= string; declare interface Foo \\{ propA: string; propB: number; \\}   需要注意的是，如何你的模块使用了 export 关键字导出了内容，上述的声明方式可能会失效，如果你依然想要将类型声明到全局，那么你就需要显式地声明到全局：\n1 2 3  declare global \\{ const ModuleGlobalFoo: string; \\}   模块作用域 就像 nodejs 中的模块一样，每个文件都是一个模块，每个模块都是独立的模块作用域。这里模块作用域触发的条件之一就是使用 export 关键字导出内容。\n每一个模块中定义的内容是无法直接在其他模块中直接获取到的，如果有需要的话，可以使用 import 关键字按需导入。\n泛型操作符作用域\u0026amp;函数作用域 泛型操作符是存在作用域的，还记得这一章的第一节为了方便大家理解，我把泛型操作符类比为函数吗？既然可以类比为函数，那么函数所具备的性质，泛型操作符自然也可以具备，所以存在泛型操作符作用域自然也就很好理解了。\n这里定义的两个同名的 T 并不会相互影响：\n1 2  type TypeOperator\\\u0026lt;T\\\u0026gt; \\= T; type TypeOperator2\\\u0026lt;T\\\u0026gt; \\= T;   上述是关于泛型操作符作用域的描述，下面我们聊一聊真正的函数作用域：\n「类型也可以支持闭包」：\n1 2 3 4 5 6 7 8 9 10 11 12  function Foo\\\u0026lt;T\\\u0026gt; \\(\\) \\{ return function\\(param: T\\) \\{ return param; \\} \\} const myFooStr \\= Foo\\\u0026lt;string\\\u0026gt;\\(\\); // const myFooStr: \\(param: string\\) =\u0026gt; string // 这里触发了闭包，类型依然可以被保留 const myFooNum \\= Foo\\\u0026lt;number\\\u0026gt;\\(\\); // const myFooNum: \\(param: number\\) =\u0026gt; number // 这里触发了闭包，类型也会保持相互独立，互不干涉   Typescript 的类型是支持 \u0026ldquo;递归\u0026rdquo; 的 Typescript 中的类型也是可以支持递归的，递归相关的问题比较抽象，这里还是举例来讲解，同时为了方便大家的理解，我也会像第一节一样，把类型递归的逻辑用 Javascript 语法描述一遍。\n首先来让我们举个栗子：\n假如现在需要把一个任意长度的元组类型中的子类型依次取出，并用 \u0026amp; 拼接并返回。 这里解决的方法其实非常非常多，解决的思路也非常非常多，由于这一小节讲的是 「递归」，所以我们使用递归的方式来解决。废话不罗嗦，先上代码：\n1 2 3 4 5 6 7 8 9 10  // shift action type ShiftAction\\\u0026lt;T extends any\\[\\]\\\u0026gt; \\= \\(\\(...args: T\\) \\=\u0026gt; any\\) extends \\(\\(arg1: any, ...rest: infer R\\) \\=\u0026gt; any\\) \\? R : never; type combineTupleTypeWithTecursion\\\u0026lt;T extends any\\[\\], E \\= \\{\\}\\\u0026gt; \\= \\{ 1: E, 0: combineTupleTypeWithTecursion\\\u0026lt;ShiftAction\\\u0026lt;T\\\u0026gt;, E \\\u0026amp; T\\[0\\]\\\u0026gt; \\}\\[T extends \\[\\] \\? 1 : 0\\] type test \\= \\[\\{ a: string \\}, \\{ b: number \\}\\]; type testResult \\= combineTupleTypeWithTecursion\\\u0026lt;test\\\u0026gt;; // \\{ a: string; \\} \\\u0026amp; \\{ b: number; \\}   看到上面的代码是不是一脸懵逼？没关系，接下来我们用普通的 Typescript 代码来 \u0026ldquo;翻译\u0026rdquo; 一下上述的代码。\n1 2 3 4 5 6 7  function combineTupleTypeWithTecursion\\(T: object\\[\\], E: object \\= \\{\\}\\): object \\{ return T.length \\? combineTupleTypeWithTecursion\\(T.slice\\(1\\), \\{ ...E, ...T\\[0\\] \\}\\) : E \\} const testData \\= \\[\\{ a: \u0026#39;hello world\u0026#39; \\}, \\{ b: 100 \\}\\]; // 此时函数的返回值为 \\{ a: \u0026#39;hello world\u0026#39;, b: 100 \\} combineTupleTypeWithTecursion\\(testData\\);   看到这儿，相信聪明的同学一下子就懂了，原来类型的递归与普通函数的递归本质上是一样的。如果触发结束条件，就直接返回，否则就一直地递归调用下去，所传递的第二个参数用来保存上一次递归的计算结果。\n当然熟悉递归的同学都知道，常见的编程语言中，递归行为非常消耗计算机资源的，一旦超出了最大限制那么程序就会崩溃。同理类型中的递归也是一样的，如果递归地过深，类型系统一样会崩溃，所以这里的代码大家理解就好，尽量不要在生产环境使用哈。\n小结 还记得一开始提出的思考题吗？其实通过上述的学习，我们完全可以自信地说出，Typescript 的 Type 本身也是一套完备的编程语言，甚至可以说是完备的图灵语言。因此类型本身也是可以用来编程的，你完全可以用它来编写一些有趣的东西，更别说是搞定日常开发中遇到的简单的业务场景了。\n\u0026ldquo;高级用法\u0026rdquo; 的使用场景与价值 哪些用法可以被称为 \u0026ldquo;高级用法\u0026rdquo; 其实所谓 \u0026ldquo;高级用法\u0026rdquo;，不过是用来解决某些特定的场景而产生的特定的约定俗称的写法或者语法糖。那高级用法重要吗？重要，也不重要。怎理解呢，根据编程中的 \u0026ldquo;二八原则\u0026rdquo;，20%的知识储备已经可以解决80%的需求问题，但是这剩余的20%，就是入门与熟练的分水岭。\n其实只要当我们仔细翻阅一遍官方提供的 handbook[4]，就已经可以应付日常开发了。但是就像本文一开头说的那样，你是否觉得：\n Typescript 在某些场景下用起来很费劲，远不及 Javascript 灵活度的十分之一。 你是否为自己使用 Javascript 中了某些 「骚操作」 用极简短的代码解决了某个复杂的代码而沾沾自喜，但却为不正确的 「返回类型」 挠秃了头。 你是否明知用了若干 as xxx 会让你的代码看起来很挫，但却无能为力，含恨而终。  同学，当你使用某种办法解决了上述的这些问题，那么这种用法就可以被称作 \u0026ldquo;高级用法\u0026rdquo;。\n举例说明 \u0026ldquo;高级用法\u0026rdquo; 的使用场景 举个栗子：在 Redux 中有一个叫作 combineReducers 的函数，因为某些场景，我们需要增加一个 combineReducersParamFactory 的函数，该函数支持传入多个函数，传入函数的返回值为作为combineReducers 的入参，我们需要整合多个入参数函数的返回值，并生成最终的对象供 combineReducers 函数使用。\n思考一下逻辑，发现其实并不复杂，用 Javascript 可以很容易地实现出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /\\*\\* \\* 合并多个参数的返回数值并返回 \\* \\@param \\{ Function\\[\\] \\} reducerCreators \\* \\@returns \\{ Object \\} \\*/ function combineReducersParamFactory\\(...reducerCreators\\) \\{ return reducerCreators.reduce\\(\\(acc, creator\\) \\=\u0026gt; \\(\\{ ...acc, ...creator\\(\\) \\}\\), \\{\\}\\) \\} // test ...  function todosReducer\\(state \\= \\[\\], action\\) \\{ switch \\(action.type\\) \\{ case \u0026#39;ADD\\_TODO\u0026#39;: return state.concat\\(\\[action.text\\]\\) default: return state \\} \\} function counterReducer\\(state \\= 0, action\\) \\{ switch \\(action.type\\) \\{ case \u0026#39;INCREMENT\u0026#39;: return state + 1 case \u0026#39;DECREMENT\u0026#39;: return state \\- 1 default: return state \\} \\} const ret \\= combineReducersParamFactory\\( \\(\\) \\=\u0026gt; \\(\\{ todosReducer \\}\\), \\(\\) \\=\u0026gt; \\(\\{ counterReducer \\}\\) \\); // \\{ todosReducer: \\[Function: todosReducer\\], counterReducer: \\[Function: counterReducer\\] \\}   但如果用需要配备对应的类型，应该如何编写呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  type Combine\\\u0026lt;T\\\u0026gt; \\= \\(T extends any \\? \\(args: T\\) \\=\u0026gt; any : never\\) extends \\(args: infer A\\) \\=\u0026gt; any \\? A : never; /\\*\\* \\* 合并多个参数的返回数值并返回 \\* \\@param \\{ Function\\[\\] \\} reducerCreators \\* \\@returns \\{ Object \\} \\*/ function combineReducersParamFactory\\\u0026lt;T extends \\(\\(...args\\) \\=\u0026gt; object\\)\\[\\]\\\u0026gt;\\(...reducerCreators: T\\): Combine\\\u0026lt;ReturnType\\\u0026lt;T\\[number\\]\\\u0026gt;\u0026gt; \\{ return reducerCreators.reduce\\\u0026lt;any\\\u0026gt;\\(\\(acc, creator\\) \\=\u0026gt; \\(\\{ ...acc, ...creator\\(\\) \\}\\), \\{\\}\\); \\} // test ...  function todosReducer\\(state: object\\[\\], action: \\{ \\[x: string\\]: string\\}\\) \\{ switch \\(action.type\\) \\{ case \u0026#39;ADD\\_TODO\u0026#39;: return state.concat\\(\\[action.text\\]\\) default: return state \\} \\} function counterReducer\\(state: number, action: \\{ \\[x: string\\]: string\\}\\) \\{ switch \\(action.type\\) \\{ case \u0026#39;INCREMENT\u0026#39;: return state + 1 case \u0026#39;DECREMENT\u0026#39;: return state \\- 1 default: return state \\} \\} // 这里不需要显示传入类型，这里就可以得到正确的代码提示 const ret \\= combineReducersParamFactory\\( \\(\\) \\=\u0026gt; \\(\\{ todosReducer \\}\\), \\(\\) \\=\u0026gt; \\(\\{ counterReducer \\}\\) \\); // \\{ todosReducer: \\[Function: todosReducer\\], counterReducer: \\[Function: counterReducer\\] \\}   你看，类型经过精心编排之后，就是可以让调用者不增加任何负担的前提下，享受到代码提示的快乐。\n小结 经过这一章节的学习，我们可以明确了解到，经过我们精心编排的类型，可以变得非常的智能，可以让调用者几乎零成本地享受到代码提示的快乐。或许在编排类型时所耗费的时间成本比较大，但是一旦我们编排完成，就可以极大地减少调用者的脑力负担，让调用者享受到编程的快乐。\n类型推导与泛型操作符 流动的类型（类型编写思路） 熟悉 「函数式编程」 的同学一定对 「数据流动」 的概念有较为深刻的理解。当你在 \u0026ldquo;上游\u0026rdquo; 改变了一个值之后，\u0026ldquo;下游\u0026rdquo; 相关的会跟着自动更新。有 「响应式编程」 经验的同学这是时候应该迫不及待地想举手了，同学把手放下，这里我们并不想深入地讨论 「流式编程思想」，之所以引出这些概念，是想类比出本小节的重点: 「流动的类型」。\n是的，编写类型系统的思路是可以借鉴 「函数式编程」 的思想的。因此某一个类型发生变化时，其他相关的类型也会自动更新，并且当代码的臃肿到不可维护的时候，你会得到一个友好的提示，整个类型系统就好像一个被精心设计过的约束系统。\nTypescript 代码哲学 聊完了类型系统的编写思路，咱们再来聊一聊代码哲学。其实之所以现在 Typescript 越来越火，撇开哪些聊烂了的优势不谈，其实最大的优势在于强大的类型表现能力，以及编辑器（VSCode）完备的代码提示能力。\n那么在这些优势的基础上，我个人拓展了一些编码哲学（习惯），这里见仁见智，大佬轻喷~：\n 减少不必要的显式类型定义，尽可能多地使用类型推导，让类型的流动像呼吸一样自然。 尽可能少地使用 any 或 as any，注意这里并不是说不能用，而是你判断出目前情况下使用 any 是最优解。 如果确定要使用 any 作为类型，优先考虑一下是否可以使用 unknown 类型替代，毕竟 any 会破坏类型的流动。 尽可能少地使用 as xxx，如果大量使用这种方式纠正类型，那么大概率你对 「类型流动」 理解的还不够透彻。  常见类型推导实现逻辑梳理与实践入门 类型的传递（流动） 前面我们说到，类型是具备流动性的，结合 「响应式编程」 的概念其实很容易理解。这一小节我们将列举几个常见的例子，来和大家具体讲解一下。\n有编程经验的同学都知道，数据是可以被传递的，同理，类型也可以。\n你可用 type 创建一个类型指针，指向对应的类型，那么就可以实现类型的传递，当然你也可以理解为指定起一个别名，或者说是拷贝，这里见仁见智，但是通过上述方法可以实现类型的传递，这是显而易见的。\n1 2 3 4 5 6 7 8 9 10 11  type RawType \\= \\{ a: string, b: number \\}; // 这里就拿到了上述类型的引用 type InferType \\= RawType; // \\{ a: string, b: number \\};  同样，类型也可以随着数据的传递而传递： var num: number \\= 100; var num2 \\= num; type Num2Type \\= typeof num2; // number   也正是依赖这一点，Typescript 才得以实现 「类型检查」、「定义跳转」 等功能。\n到这里熟悉 「流式编程」 的同学就要举手了：你光说了类型的 「传递」，「输入」 与 「输出」，那我如果希望在类型 「传递」 的过程中对它进行操作，该怎么做呢？同学你不要急，这正是我下面所想要讲的内容。\n类型的过滤与分流 在上一小节中，我们反复地扯到了 「函数式编程」、「响应式编程」、「流式编程」 这些抽象的概念，其实并不是跑题，而是者两者的思想（理念）实在太相似了，在本小节后续的讲解中，我还会一直延用这些概念帮助大家理解。翻看一下常用 「函数式编程」 的库，不管是 Ramda 、RXJS 还是我们耳熟能详的 lodash 、underscore，里面一定有一个操作符叫作 filter，也就是对数据流的过滤。\n这个操作符的使用频率一定远超其他操作符，那么这么重要的功能，我们在类型系统中该如何实现呢？\n要解决这个问题，这里我们先要了解一个在各大 技术社区/平台 搜索频率非常高的一个问题:\n「TypeScript中 的 never 类型具体有什么用？」\n既然这个问题搜索频率非常之高，这里我也就不重复作答，有兴趣的同学可以看一下尤大大的回答： TypeScript中的never类型具体有什么用？ - 尤雨溪的回答 - 知乎[5]。\n这里我们简单总结一下：\n never 代表空集。 常用于用于校验 \u0026ldquo;类型收窄\u0026rdquo; 是否符合预期，就是写出类型绝对安全的代码。 never 常被用来作 \u0026ldquo;类型兜底\u0026rdquo;。  当然上面的总结并不完整，但已经足够帮助理解本小节内容，感兴趣的同学可以自行查阅相关资料。\n上面提到了 \u0026ldquo;类型收窄\u0026rdquo;，这与我们的目标已经十分接近了，当然我们还需要了解 never 参与类型运算的相关表现：\n1 2  type NeverTest \\= string | never // stirng type NeverTest2 \\= string \\\u0026amp; never // never   重要的知识出现了：T | never，结果为 T。\n看到这里，相信聪明的同学们已经有思路了，我们可以用 never 来过滤掉 联合类型(Union Types) 中不和期望的类型，其实这个 「泛型操作符」 早在 Typescript 2.8[6] 就已经被加入到了官方文档中了。\n1 2 3 4  /\\*\\* \\* Exclude from T those types that are assignable to U \\*/ type Exclude\\\u0026lt;T, U\\\u0026gt; \\= T extends U \\? never : T;   相信经过这么长时间的学习，看到这里你一定很容易就能这种写法的思路。\n好了，讲完了 「过滤」，我们再来讲讲 「分流」。类型 「分流」 的概念其实也不难理解，这个概念常常与逻辑判断一同出现，毕竟从逻辑层面来讲，联合类型(Union Types) 本质上还是用来描述 「或」 的关系。同样的概念如果引入到 「流式编程」 中，就自然而然地会引出 「分流」。换成打白话来讲，就是不同数据应被分该发到不同的 「管道」 中，同理，类型也需要。\n那么这么常用的功能，在 Typescript 中如何处理呢？其实这种常见的问题，官方也非常贴心地为我们考虑到了，那就是：类型守卫（Type guard）。网上对 类型守卫（Type guard） 有讲解的文章非常的多，这里也不作赘述，有兴趣的同学可以自行搜索学习。我们这里用一个简单的栗子简单地演示一下用法：\n1 2 3 4 5 6 7  function foo\\(x: A | B\\) \\{ if \\(x instanceof A\\) \\{ // x is A  \\} else \\{ // x is B  \\} \\}   「可以触发类型守卫的常见方式有」：typeof、instanceof、in、==、 ===、 !=、 !== 等等。\n当然在有些场景中，单单通过以上的方式不能满足我们的需求，该怎么办呢？其实这种问题，官方也早已经帮我考虑到了：使用 is 关键字自定义 类型守卫（Type guard）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 注意这里需要返回 boolean 类型 function isA\\(x\\): x is A \\{ return true; \\} // 注意这里需要返回 boolean 类型 function isB\\(x\\): x is B \\{ return x instanceof B; \\} function foo2\\(x: unknown\\) \\{ if \\(isA\\(x\\)\\) \\{ // x is A  \\} else \\{ // x is B  \\} \\}   小结 这一章节中，我们通过类比 响应式编程、流式编程 的概念方式，帮助大家更好地理解了 「类型推导」 的实现逻辑与思路，相信经过了这一章节的学习，我们对 Typescript 中的类型推导又有了更加深入的理解。不过这一章引入的抽象的概念比较多，也比较杂，基础不是太好的同学需要多花点时间翻看一下相关资料。\n定制化扩展你的 Typescript Typescript Service Plugins 的产生背景、功能定位、基础使用 产生背景 说起 Typescript 的编译手段大部分同学应该都不会陌生，无论是在 webpack 中使用 ts-loader 或 babel-loader，还是在 gulp 中使用 gulp-typescript，亦或是直接使用 Typescript 自带的命令行工具，相信大部分同学也都已经驾轻就熟了，这里不做赘述。\n这里我们把目光聚焦到撸码体验上，相信有使用过 Typescritp 开发前端项目的同学一定有过各种各样的困扰，这里列举几个常见的问题：\n 在处理 CSS Module 的样式资源的类型定义时，不满足于使用 declare module '*.module.css' 这种毫无卵用的类型定义。 不想给编辑器安装各种各样的插件，下次启动编辑器的时间明显变长，小破电脑不堪重负，而且每次重装系统都是一次噩梦降临。 不想妥协于同事的使用习惯，想使用自己熟悉的编辑器。 并不满足于官方已有的代码提示，想让自己的编辑器更加地贴心与智能。  为了提供更加贴心的开发体验，Typescript 官方提供一种解决思路——Typescript Service Plugins 功能定位 以下内容摘自官方 WIKI：  ❝In TypeScript 2.2 and later, developers can enable language service plugins to 「augment the TypeScript code editing experience」. ❞\n 其实官方文档已经写的很清楚了，这玩意儿旨在优化 Typescript 代码的 「编写体验」。所以想利用这玩意儿改变编译结果或是想自创新语法的还是省省吧 嗯，我在说我自己呢！\n那么 Typescript Service Plugins 的可以用来做哪些事呢？\n官方也有明确的回答：\n ❝plugins are for augmenting the editing experience. Some examples of things plugins might do:\n  Provide errors from a linter inline in the editor Filter the completion list to remove certain properties from window Redirect \u0026ldquo;Go to definition\u0026rdquo; to go to a different location for certain identifiers Enable new errors or completions in string literals for a custom templating language  ❞\n同样官方也给出了不推荐使用 Typescript Service Plugins 的场景：\n ❝Examples of things language plugins cannot do:\n  Add new custom syntax to TypeScript Change how the compiler emits JavaScript Customize the type system to change what is or isn\u0026rsquo;t an error when running tsc  ❞\n好了，相信读到这里大家一定对 Typescript Service Plugins 有了一个大致的了解，下面我会介绍一下 Typescript Service Plugins 的安装与使用。\n如何安装以及如何配置 Typescript Service Plugins Typescript Service Plugins 的安装方法 # 就像安装普通的 `npm` 包一样\nnpm install \\--save\\-dev your\\_plugin\\_name 如何在 tsconfig.json 中配置 Typescript Service Plugins \\{ \u0026quot;compilerOptions\u0026quot;: \\{ /\\*\\* compilerOptions Configuration ... \\*/ \u0026quot;noImplicitAny\u0026quot;: true, \u0026quot;plugins\u0026quot;: \\[ \\{ /\\*\\* 配置插件名称，也可以填写本地路径 \\*/ \u0026quot;name\u0026quot;: \u0026quot;sample-ts-plugin\u0026quot; /\\*\\* 这里可以给插件传参 ... \\*/ \\} /\\*\\* 支持同时引入多个插件 ... \\*/ \\] \\} \\} 几个需要注意的地方:  如果使用 VSCode 开发，记得务必 using the workspace version of typescript[7]，否则可能导致插件不生效。 Typescript Service Plugins 产生的告警或者报错不会影响编译结果。 如果配置完了不生效可以先尝试重启你的编辑器。  市面上已有的 Typescript Service Plugins 举例介绍  ❝具体使用细节请用编辑器打开我提供的 demo，自行体验。 ❞\n 示例插件：typescript-plugin-css-modules[8] 插件安装 npm install \\--save\\-dev typescript\\-styled\\-plugin typescript 配置方法 在 tsconfig.json 中增加配置 \\{ \u0026quot;compilerOptions\u0026quot;: \\{ \u0026quot;plugins\u0026quot;: \\[ \\{ \u0026quot;name\u0026quot;: \u0026quot;typescript-styled-plugin\u0026quot; /\\*\\* 具体配置参数请查看官方文档 \\*/ \\} \\] \\} \\} 插件基本介绍与使用场景 此插件可以用来缓解在使用 CSS Module 时没有代码提示的困境，主要思路就是通过读取对应的 CSS Module 文件并解析成对应的 AST，并生成对应的类型文件从而支持对应的代码提示。但是根据反馈来看，似乎某些场景下表现并不尽人意，是否值得大规模使用有待商榷。\n类似实现思路的还有 typings-for-css-modules-loader[9]，功能来说肯定是 webpack loader 更加强大，但是 Typescript Plugin 更加轻量、入侵度也越低，取舍与否，见仁见智吧\n示例插件：typescript-eslint-language-service[10] 插件安装 npm install \\--save\\-dev eslint typescript\\-eslint\\-language\\-service 配置方法 在 .eslintrc.* 文件中，添加对应的 eslint 配置\n在 tsconfig.json 中增加配置 1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;plugins\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;typescript-eslint-language-service\u0026#34; /*\\* 默认会读取 \\`.eslintrc.\\*\\` 文件 \\*/ /*\\* 具体配置参数请查看官方文档 \\*/ } ] } }   插件基本介绍与使用场景 此插件可以让 Typescript 原生支持 eslint 检查及告警，编辑器不需要安装任何插件即可自持，但是报错并不影响编译结果。\n示例插件：typescript-styled-plugin[11] 插件安装 npm install \\--save\\-dev typescript\\-styled\\-plugin typescript 配置方法 在 tsconfig.json 中增加配置 \\{ \u0026quot;compilerOptions\u0026quot;: \\{ \u0026quot;plugins\u0026quot;: \\[ \\{ \u0026quot;name\u0026quot;: \u0026quot;typescript-styled-plugin\u0026quot; /\\*\\* 具体配置参数请查看官方文档 \\*/ \\} \\] \\} \\} 插件基本介绍与使用场景 此插件可以为 styled-components[12] 的样式字符串模板提供 属性/属性值 做语法检查。 同时也推荐安装 VSCode 插件 vscode-styled-components[13]，为你的样式字符串模板提供代码提示以及语法高亮。\n参考资料链接  Using the Compiler API[14] Using the Language Service API[15] Writing a Language Service Plugin[16] Useful Links for TypeScript Issue Management[17]  Q\u0026amp;A 可以利用 Typescript Service Plugin（例如配置 eslint 规则）阻塞编译或者在编译时告警吗？ 「答」：不可以，所有可以使用 Typescript Plugin 的场景一定都是编码阶段的，而且官方对 plugins 的定位局限在了 只改善编写体验 这方面，你并不能自定义语法或者自定义规则来改变编译结果，不过你可以考虑使用自定义 compiler，当然这是另一个话题了。\n以下引用自官方文档：\n ❝TypeScript Language Service Plugins (\u0026ldquo;plugins\u0026rdquo;) are for changing the 「editing experience only」. The core TypeScript language remains the same. Plugins can\u0026rsquo;t add new language features such as new syntax or different typechecking behavior, and 「plugins aren\u0026rsquo;t loaded during normal commandline typechecking or emitting」. ❞\n Reference [1]\nTypescript 官网: https://www.typescriptlang.org/\n[2]\nTypeScript Deep Dive: https://basarat.gitbook.io/typescript/\n[3]\nTypeScript GitHub地址: https://github.com/microsoft/TypeScript\n[4]\nhandbook: https://www.typescriptlang.org/docs/handbook/basic-types.html\n[5]\nTypeScript中的never类型具体有什么用？ - 尤雨溪的回答 - 知乎: https://www.zhihu.com/question/354601204/answer/888551021\n[6]\nTypescript 2.8: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types\n[7]\nusing the workspace version of typescript: https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript\n[8]\ntypescript-plugin-css-modules: https://www.npmjs.com/package/typescript-plugin-css-modules\n[9]\ntypings-for-css-modules-loader: https://www.npmjs.com/package/@teamsupercell/typings-for-css-modules-loader\n[10]\ntypescript-eslint-language-service: https://www.npmjs.com/package/typescript-eslint-language-service\n[11]\ntypescript-styled-plugin: https://www.npmjs.com/package/typescript-styled-plugin\n[12]\nstyled-components: https://www.npmjs.com/package/styled-components\n[13]\nvscode-styled-components: https://github.com/styled-components/vscode-styled-components\n[14]\nUsing the Compiler API: https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API\n[15]\nUsing the Language Service API: https://github.com/microsoft/TypeScript/wiki/Using-the-Language-Service-API\n[16]\nWriting a Language Service Plugin: https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\n[17]\nUseful Links for TypeScript Issue Management: https://github.com/microsoft/TypeScript/wiki/Useful-Links-for-TypeScript-Issue-Management\n","description":"","id":6,"section":"posts","tags":["javascript","typescript"],"title":"深入理解 Typescript 高级用法","uri":"https://yichenlove.github.io/posts/typescripts-high/"},{"content":"JIT，即Just-in-time,动态(即时)编译，边运行边编译；AOT，Ahead Of Time，指运行前编译，是两种程序的编译方式\n区别 这两种编译方式的主要区别在于是否在“运行时”进行编译\n优劣 JIT优点：  可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译） 可以根据当前程序的运行情况生成最优的机器指令序列 当程序需要支持动态链接时，只能使用JIT 可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用  JIT缺点：  编译需要占用运行时资源，会导致进程卡顿 由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡 在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能  AOT优点：  在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗 可以在程序运行初期就达到最高性能 可以显著的加快程序的启动  AOT缺点：  在程序运行前编译会使程序安装的时间增加 牺牲Java的一致性 将提前编译的内容保存会占用更多的外  与Android的关联 Android在2.2的时候引入JIT，在kitkat时新增了ART(Android RunTime),在Android L时使用ART完全替代了Dalvik作为默认的虚拟机环境。\nDalvik  Dalvik使用JIT 使用.dex字节码，是针对Android设备优化后的DVM所使用的运行时编译字节码 .odex是对dex的优化，deodex在系统第一次开机时会提取所有apk内的dex文件，odex优化将dex提前提取出，加快了开机的速度和程序运行的速度  ART  ART 使用AOT 在安装apk时会进行预编译，生成OAT文件，仍以.odex保存，但是与Dalvik下不同，这个文件是可执行文件 dex、odex 均可通过dex2oat生成oat文件，以实现兼容性 在大型应用安装时需要更多时间和空间  Android N引入的混合编译 在Android N中引入了一种新的编译模式，同时使用JIT和AOT。这是我在网上找到的一些解释：\n 包含了一个混合模式的运行时。应用在安装时不做编译，而是解释字节码，所以可以快速启动。ART中有一种新的、更快的解释器，通过一种新的JIT完成，但是这种JIT的信息不是持久化的。取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART会执行针对“热代码”进行的基于分析的编译，其他代码不做编译。为了得到更优的代码，ART采用了几种技巧包括深度内联。\n对同一个应用可以编译数次，或者找到变“热”的代码路径或者对已经编译的代码进行新的优化，这取决于分析器在随后的执行中的分析数据。\n 这些大概说的是新的ART在安装程序时使用JIT，在JIT编译了一些代码后将这些代码保存到本地，等到设备空闲的时候将保存的这些代码使用AOT编译生成可执行文件保存到本地，待下次运行时直接使用，并且不断监视代码的更新，在代码有更新后重新生成可执行文件。\n","description":"","id":7,"section":"posts","tags":null,"title":"AOT和JIT","uri":"https://yichenlove.github.io/posts/aot-jit/"},{"content":"算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。\n那么我们应该如何去衡量不同算法之间的优劣呢？\n主要还是从算法所占用的「时间」和「空间」两个维度去考量。\n 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。  因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。\n下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。\n一、时间复杂度 我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。\n这种方式可以吗？当然可以，不过它也有很多弊端。\n这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。\n因此，另一种更为通用的方法就出来了：「 大O符号表示法 」，即 T(n) = O(f(n))\n我们先来看个例子：\n1 2 3 4 5  for(i=1; i\u0026lt;=n; ++i) { j = i; j++; }   通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?\n在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。\n我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)\n为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。\n所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。\n常见的时间复杂度量级有：\n 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n²) 立方阶O(n³) K次方阶O(n^k) 指数阶(2^n)  上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。\n下面选取一些较为常用的来讲解一下（没有严格按照顺序）：\n 常数阶O(1)  无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\n1 2 3 4 5  int i = 1; int j = 2; ++i; j++; int m = i + j;   上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。\n 线性阶O(n)  这个在最开始的代码示例中就讲解过了，如：\n1 2 3 4 5  for(i=1; i\u0026lt;=n; ++i) { j = i; j++; }   这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。\n 对数阶O(logN)  还是先来看代码：\n1 2 3 4 5  int i = 1; while(i\u0026lt;n) { i = i * 2; }   从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n\n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)\n 线性对数阶O(nlogN)  线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。\n就拿上面的代码加一点修改来举例：\n1 2 3 4 5 6 7 8  for(m=1; m\u0026lt;n; m++) { i = 1; while(i\u0026lt;n) { i = i * 2; } }    平方阶O(n²)  平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。\n举例：\n1 2 3 4 5 6 7 8  for(x=1; i\u0026lt;=n; x++) { for(i=1; i\u0026lt;=n; i++) { j = i; j++; } }   这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)\n如果将其中一层循环的n改成m，即：\n1 2 3 4 5 6 7 8  for(x=1; i\u0026lt;=m; x++) { for(i=1; i\u0026lt;=n; i++) { j = i; j++; } }   那它的时间复杂度就变成了 O(m*n)\n 立方阶O(n³)、K次方阶O(n^k)  参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。\n除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。\n二、空间复杂度 既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。\n空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。\n空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：\n 空间复杂度 O(1)  如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)\n举例：\n1 2 3 4 5  int i = 1; int j = 2; ++i; j++; int m = i + j;   代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)\n 空间复杂度 O(n)  我们先看一个代码：\n1 2 3 4 5 6  int[] m = new int[n] for(i=1; i\u0026lt;=n; ++i) { j = i; j++; }   这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)\n以上，就是对算法的时间复杂度与空间复杂度基础的分析。\n","description":"","id":8,"section":"posts","tags":["algorithms"],"title":"算法的时间与空间复杂度","uri":"https://yichenlove.github.io/posts/algorithms-0/"},{"content":"01\n验证对于IC的重要性\nIC是集成电路的缩写，也就是我们常说的芯片；IC行业的技术门槛高、投入资金大、回报周期长、失败风险高，做一款中等规模的芯片大致需要10多人做1年半，开模的费用一般都在几百万，设计过程的笔误或者设计bug至少都会有上千个，由于设计缺陷或者工艺缺陷很容易造成芯片完全变成所谓的石头，而如果要重新头片不但需要投入额外的费用，更会将芯片上市时间延后至少半年，这些风险对于商业公司来说都是不可接受的。\n正因为芯片的高风险，才凸显了验证的重要性。在流片之前，通过验证人员的验证活动发现所有的设计bug，这就显得特别重要。\n02\n验证的一目标\n做验证首先要明确我们做IC验证的目标是什么。上面我们已经提到，由于芯片的高风险、高代价，才更突出了验证的重要性，尤其是芯片规模越来越大，逻辑越来越复杂。\n为了保证芯片的成功，验证唯一的目标就是发现所有的bug，做到无漏验、零漏测。\n03\n验证的两问题\n作为验证人员，首先要搞清楚两个问题：\n1）我们要验证什么？\n2）我们该怎么验？\n这两个问题是验证的根本，就如同哲学里的“我是谁、我来自哪儿、我要去哪儿”一样，“我们要验什么？”是给我们指明目标，”我们该怎么验？“则是告诉我们该采用什么样的手段去达到这个目标。\n如果这2个问题都没搞清楚，那么没人对你负责验证的模块有信心，毕竟你自己都不知道你的目标是什么，不知道该怎么做才能达到那个目标。这两个问题是验证的核心所在，如果想做好验证，这是前提。\n04\n验证的三板斧\n要想做好验证，保证无漏验、零漏测，以下三个要素是必须要具备的：验证工具的掌握、算法/协议的理解、验证的意识。\n1）验证工具的掌握\n验证工具包括vmm/uvm等验证方法学、sv/sc等验证语言、vcs等验证仿真工具、perl/python等脚本语言，这些东西是做验证要掌握的基本技能，不论你做什么样的芯片都需要这些东西来支撑你的验证工作。\n这些验证工具可以帮助你解决“我们该怎么验”这个问题，当你很好的掌握这些验证工具后，你可以有很多种方法途径去达成你的验证目标。\n说实在话，验证工具的东西很多，要想在短时间内全部掌握也不可能，而且很多工具可能在你的验证过程中不会用到。\n个人对验证工具的一点感悟是：不要贪求全部掌握，你可以先看书学习实践，把这些东西都学习一遍；在学习的过程中你肯定会发现一些好东西（原来还有这种方法可以让我的xx做的更好）；对于那些暂时不知道怎么应用到实践中的东西，你也不要认为它们是没用的，其实只是你不知道用在哪儿而已，在你以后的验证中也许就会发现它的应用场景，当你需要它的时候也许你已经忘记怎么用了，这个没关系，你可以再回去查阅资料，这个相信很快就能解决的，这样有个好处是当你碰到可以用xx的时候你至少能想起曾经看到某个东西可以来实现它，如果你从未学习过，那么你根本就不会想起有这么个方法可以解决它，这才是可怕的，我都不知道这个问题是可以被解决的。\n2）算法/协议的理解\n芯片要实现什么，不外乎是xx算法、某某协议，算法/协议才是芯片的魂。验证其实也就是验的算法/协议实现是否正确。就跟批改作文一样，只有批改者有一定的文学功底，才能更好的评判作文水平。\n因此，验证人员对算法/协议理解越深刻越好，要理解算法的原理以及算法的实现结构，只有这样才能找出其中的corner点。\n3）验证的意识\n验证的意识究竟是什么，其实我也说不清楚，只能按照我自己的理解写写一些。\n· 对任何东西都要有质疑的态度\n· 手要伸长，延伸到上下游\n· 对问题要刨根问底\n05\n验证的流程\n做任何事情都需要按照一定的流程来走，否则很容易陷入混乱之中，尤其是对于刚入门的新手来说更是如此。我目前接触的通用流程大致如下：\n1）提取测试点，明确验什么\n· 分析FS/浮点平台，提取芯片的规格及测试点；\n· 分析AS/定点平台，提取测试点；\n· 分析DS，提取测试点并识别asic与算法的不一致点；\n2）制定验证方案，明确怎么验\n· 刷新测试点列表，明确测试点的覆盖方式：功能覆盖率、代码覆盖率、直接用例；\n· 验证环境的搭建策略，这个步骤是可以做成自动化工具的；\n· 验证的重点难点，提前识别重难点，并制定相应的对策；\n· 刷新用例列表，明确测试用例的方法及步骤；\n3）用例执行，随机测试，发现bug\n· 执行直接用例，发现大部分的bug；\n· 带随机的大量测试，试图撞出bug；\n4）完备性分析，确保无漏验\n· FA/AS完备性确认，确认FS/AS中的所有点都已纳入测试点，并确保已被覆盖，包括应用场景；\n· 接口完备性确认，保证所有的接口时序都已覆盖，包括正常时序及异常时序；\n· 覆盖率确认，分析所有的代码覆盖率、功能覆盖率，保证全部覆盖；\n· 代码分析，熟练掌握电路的实现逻辑，保证所有的电路corner都已覆盖；\n上述这几个步骤是一个比较规范的流程，只要每个步骤都做好，基本就能做到无漏测、零漏验。\n06\n验证的后话\n1）验证的空间\n作为验证人员最希望的情况是：把所有的激励空间都覆盖到，这样就绝对能保证无漏测、零漏验。但实际情况是：芯片规模越来越大，其激励空间近乎无限，同时EDA仿真的速度奇慢，根本无法实现全覆盖，即使是FPGA、EMU等仿真加速器对此也是无能为力。\n因此，合理划分激励等价类是相当重要的，但这也一直是验证的难点所在，很多情况下根本就没法分析清楚等价类。\n2）CDV验证\nCDV就是覆盖率驱动验证的意思，就是写一大堆覆盖率（断言覆盖率、功能覆盖率、代码覆盖率），只要这些覆盖率全都达到的话则表示验证已经完备。\n这是我们的目标，其前提是分析清楚我们的测试点覆盖空间，这个分析也是让人头痛的事，没有谁敢拍着胸脯说这个测试点空间是完备的。\n3）formal验证\n传统的仿真都是动态验证，由于其仿真效率低下无法遍历所有空间，formal这种静态的验证手段则可以遍历所有空间。不过在目前这个阶段，formal还只能适用于百万门级的模块验证，同时目前市面上的formal工具大多要么只对控制逻辑支持较好，要么只对算法逻辑支持较好，几乎没有一款formal工具能完美支持所有的电路逻辑。\n4）环境自动化\n在验证过程中，搭建验证环境是一个机械性的劳动，但有时候又比较耗费时间而且容易出错，因此把验证环境做成自动化工具，还是能提高不少验证效率的。\n5）全部使用直接用例\n从验证流程中可以看到，用例执行过程中大部分bug在直接用例过程中被发现，但还有一部分隐藏比较深的bug只有通过随机激励来发现。\n这里存在一个问题，随机测试是不可靠的，有很大的概率发现不了隐藏的bug，对此可以有两种方法：\n一是采用带约束的随机，这样可以更好的达到边界点，这同样存在概率性问题；\n二是所有的corner点全部用直接用例覆盖，这些直接用例执行一次即可发现所有的bug，根本不需要进行长期的随机测试，这要求我们能识别出所有的corner点；\n方法二是我们追求的目标，全部用直接用例覆盖，取代长期随机测试，可惜愿望是美好的。\n6）复用的东西都BB化\n在芯片设计中经常回重用以前的模块，这样不仅加快进度，而且能降低出错风险；但是对于验证人员来说，复用并不一定是好事情，经常会出现这样的事情：由于是复用之前的模块，所以在验证的时候会掉以轻心，结果埋下bug。如果把复用模块当做全新模块来验证，这又要花费大量的时间，可能就会延后芯片的投片时间。\n对于复用的模块，验证人员也可以把验证的相关东西做成BB化，后续芯片复用该模块时，也可以复用该验证BB。\n","description":"","id":9,"section":"posts","tags":["IC"],"title":"IC设计验证参考","uri":"https://yichenlove.github.io/posts/ic-verification/"},{"content":"要点：  char与int ：可以相加减；int取本身数值，char取对应的ASCII码值；得到的结果是ASCII码增大或减小了int对应的数值大小；如果结果赋值给char类型的变量即是该ASCII码对应的字符，如果赋值给int类型的变量即是该ASCII码的大小。  1 2 3 4 5 6 7 8  public class Test { public static void main(String[] args) { char c = \u0026#39;2\u0026#39;-3;//\u0026#39;2\u0026#39;的ASCII码:50  int i = \u0026#39;2\u0026#39;-3; System.out.println(\u0026#34;c:\u0026#34;+c);//\u0026#39;/\u0026#39;的ASCII码:47  System.out.println(\u0026#34;i:\u0026#34;+i); } }    c:/\ni:47\n  char与char ：可以相加减；都取各自对应的ASCII码进行加减；如果结果赋值给char类型的变量即是该ASCII码对应的字符，如果赋值给int类型的变量即是该ASCII码的大小。  1 2 3 4 5 6 7 8  public class Test { public static void main(String[] args) { char c = \u0026#39;a\u0026#39;-\u0026#39;1\u0026#39;;//\u0026#39;a\u0026#39;的ASCII码：97，\u0026#39;1\u0026#39;的ASCII码：49 \tint i = \u0026#39;a\u0026#39;-\u0026#39;1\u0026#39;; System.out.println(\u0026#34;c:\u0026#34;+c);//\u0026#39;0\u0026#39;的ASCII码：48 \tSystem.out.println(\u0026#34;i:\u0026#34;+i); } }    c:0\ni:48\n  String与int ：只能加不能减；得到的结果为String类型。  1 2 3 4 5 6  public class Test { public static void main(String[] args) { String s = \u0026#34;2\u0026#34;+3; System.out.println(\u0026#34;s:\u0026#34;+s); } }    s:23\n 例题：  把字符串转换成整数。\n将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。\n输入描述:\n输入一个字符串,包括数字字母符号,可以为空\n输出描述:\n如果是合法的数值表达则返回该数字，否则返回0\n1 2 3 4 5 6 7 8 9 10 11 12  public static int StrToInt(String str) { if(!str.matches(\u0026#34;(-|\\\\+)?\\\\d+\u0026#34;))//匹配可能带有正负号的数字形式的字符串  return 0; int res = 0; int flag = 1; char strArr[] = str.toCharArray(); if(strArr[0] == \u0026#39;-\u0026#39;) flag = -1; for (int i = (strArr[0]==\u0026#39;+\u0026#39;||strArr[0]==\u0026#39;-\u0026#39;)?1:0; i \u0026lt; strArr.length; i++) res = res*10 + strArr[i] - \u0026#39;0\u0026#39;;//注意这里根据strArr[i] - \u0026#39;0\u0026#39;的差值得到strArr[i]对应的数字  return res*flag; }    ","description":"","id":10,"section":"posts","tags":["java"],"title":"Java中char，int，String的相加减","uri":"https://yichenlove.github.io/posts/java-char-add/"},{"content":"# 一、场景复现 一个经典的面试题\n1  0.1 + 0.2 === 0.3 // false   为什么是false呢?\n先看下面这个比喻\n比如一个数 1÷3=0.33333333\u0026hellip;\u0026hellip;\n3会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但0.333333\u0026hellip;\u0026hellip; 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题\n# 二、浮点数 “浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储\n我们也可以理解成，浮点数就是小数\n在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码\n这样的存储结构优点是可以归一化处理整数和小数，节省存储空间\n对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了\n而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：\n其中，a的值为0或者1，e为小数点移动的位置\n举个例子：\n27.0转化成二进制为11011.0 ，科学计数法表示为：\n前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特\n64位比特又可分为三个部分：\n 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零  如下图所示：\n举个例子：\n27.5 转换为二进制11011.1\n11011.1转换为科学记数法 符号位为1(正数)，指数位为4+，1023+4，即1027\n因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`\n所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示\n0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`\n# 二、问题分析 再回到问题上\n1  0.1 + 0.2 === 0.3 // false   通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都转化成二进制后再进行运算\n1 2 3 4 5 6  // 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010 + 0.0011001100110011001100110011001100110011001100110011010 = 0.0100110011001100110011001100110011001100110011001100111 // 转成十进制正好是 0.30000000000000004   所以输出false\n再来一个问题，那么为什么x=0.1得到0.1？\n主要是存储二进制时小数点的偏移量最大为52位，最多可以表达的位数是2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度\n它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理\n1 2  .10000000000000000555.toPrecision(16) // 返回 0.1000000000000000，去掉末尾的零后正好为 0.1   但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：\n1  0.1.toPrecision(21) = 0.100000000000000005551   如果整数大于 9007199254740992 会出现什么情况呢？\n由于指数位最大值是1023，所以最大可以表示的整数是 2^1024 \\- 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity\n1 2 3 4 5  \u0026gt; Math.pow(2, 1023) 8.98846567431158e+307 \u0026gt; Math.pow(2, 1024) Infinity   那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？\n (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数 \u0026hellip; 依次跳过更多2的倍数  要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多\n# 小结 计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法\n因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差\n# 三、解决方案 理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果\n当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：\n1  parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True   封装成方法就是：\n1 2 3  function strip(num, precision = 12) { return +parseFloat(num.toPrecision(precision)); }   对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：\n1 2 3 4 5 6 7 8 9  /** * 精确加法 */ function add(num1, num2) { const num1Digits = (num1.toString().split(\u0026#39;.\u0026#39;)[1] || \u0026#39;\u0026#39;).length; const num2Digits = (num2.toString().split(\u0026#39;.\u0026#39;)[1] || \u0026#39;\u0026#39;).length; const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); return (num1 * baseNum + num2 * baseNum) / baseNum; }   最后还可以使用第三方库，如Math.js、BigDecimal.js\n# 参考文献  https://zhuanlan.zhihu.com/p/100353781 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt  ","description":"","id":11,"section":"posts","tags":["javascript"],"title":"说说 Javascript 数字精度丢失的问题，如何解决？","uri":"https://yichenlove.github.io/posts/javascripts-float/"},{"content":"你安装的是SUN/Oracle JDK还是OpenJDK? 还傻傻分不清楚吗? 快来看看这篇吧😁\n目录\n 1 如何查看你安装的JDK版本  1.1 要用到的命令行工具 1.2 查看JDK的版本   2 什么是 OpenJDK  2.1 OpenJDK 的来历 2.2 Oracle JDK的来历   3 Oracle JDK与OpenJDK的区别  3.1 主要不同 3.2 授权协议的不同 3.3 OpenJDK不包含Deployment功能 3.4 OpenJDK源码不完整    1 如何查看你安装的JDK版本 1.1 要用到的命令行工具  Windows系统的cmd命令行工具;\nLinux或macOS系统的Terminal终端;\n 1.2 查看JDK的版本 1  java -version   (1) 如果是SUN/OracleJDK, 显示信息为:\n1 2 3 4  [root@localhost ~]# java -version java version \u0026#34;1.8.0_162\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)   说明:\n Java HotSpot(TM) 64-Bit Server VM 表明, 此JDK的JVM是Oracle的64位HotSpot虚拟机, 运行在Server模式下(虚拟机有Server和Client两种运行模式).\nJava(TM) SE Runtime Environment (build 1.8.0_162-b12) 是Java运行时环境(即JRE)的版本信息.\n (2) 如果OpenJDK, 显示信息为:\n1 2 3 4  [root@localhost ~]# java -version openjdk version \u0026#34;1.8.0_144\u0026#34; OpenJDK Runtime Environment (build 1.8.0_144-b01) OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode)   PS. 主要的Linux发行版(如Ubuntu, Fedora和Red Hat Enterprise Linux) 提供OpenJDK或其变体作为系统默认的Java SE的实现.\n2 什么是 OpenJDK 百度百科上关于OpenJDK的说明:\n Sun发布的OpenJDK是一款只能运行在i386和AMD-64机器上的软件。\n 2.1 OpenJDK 的来历 Java由SUN公司(Sun Microsystems, 发起于美国斯坦福大学, SUN是Stanford University Network的缩写)发明, 2006年SUN公司将Java开源, 此时的JDK即为OpenJDK.\n也就是说, OpenJDK是Java SE的开源实现, 它由SUN和Java社区提供支持, 2009年Oracle收购了Sun公司, 自此Java的维护方之一的SUN也变成了Oracle .\n大多数JDK都是在OpenJDK的基础上编写实现的, 比如IBM J9, Azul Zulu, Azul Zing和Oracle JDK. 几乎现有的所有JDK都派生自OpenJDK, 它们之间不同的是许可证:\n OpenJDK根据许可证GPL v2发布;\nOracle JDK根据Oracle二进制代码许可协议获得许可.\n 2.2 Oracle JDK的来历 Oracle JDK之前被称为SUN JDK, 这是在2009年Oracle收购SUN公司之前, 收购后被命名为Oracle JDK.\n实际上, Oracle JDK是基于OpenJDK源代码构建的, 因此Oracle JDK和OpenJDK之间没有重大的技术差异.\nOracle的项目发布经理Joe Darcy在OSCON 2011 上对两者关系的介绍也证实了OpenJDK 7和Oracle JDK 7在程序上是非常接近的, 两者共用了大量相同的代码(如下图), 注意: 图中提示了两者共同代码的占比要远高于图形上看到的比例, 所以我们编译的OpenJDK基本上可以认为性能、功能和执行逻辑上都和官方的Oracle JDK是一致的.\n3 Oracle JDK与OpenJDK的区别 3.1 主要不同 OpenJDK Font Renderer(字体栅格化引擎) 和Oracle JDK Flight Recorder(飞行记录仪) 是Oracle JDK和OpenJDK之间明显的主要区别. —— 存疑, 尚未求证.\n OpenJDK使用的是开源免费的FreeType, 可以按照GPL v2许可证使用.\nOracle JDK采用了商业实现, 其中的Flight Recorder和MissionControl都是从JRockit中改造而来的.\n JRockit是Oracle的JVM, 从Java SE 7开始, HotSpot和JRockit合并为一个JVM.\n3.2 授权协议的不同 OpenJDK采用GPL V2协议放出, 而Oracle JDK则采用JRL(Java Research License, Java研究授权协议) 放出. 两种者虽然都是开放源代码的, 但在使用上却要注意:\n GPL V2允许在商业上使用;\nJRL只允许个人研究使用, 要获得Oracle JDK的商业许可证, 需要联系Oracle的销售人员进行购买.\n 3.3 OpenJDK不包含Deployment功能 部署的功能包括: Browser Plugin、Java Web Start、Java Mission Control, 这些功能OpenJDK都没有.\n3.4 OpenJDK源码不完整 在采用GPL协议的OpenJDK中, SUN JDK的一部分源码因为产权问题无法提供给OpenJDK使用, 其中最主要的是JMX中的可选元件SNMP部份的代码, 因此这些不能开放的源码将它作成plug, 以供 OpenJDK编译时使用.\n 参考资料 如何看本地安装的jdk是Sun/Oraclejdk还是Openjdk\nOracle JDK vs OpenJDK and Java JDK Development Process\nDifferences between Oracle JDK and OpenJDK\n  版权声明 作者: 马瘦风\n出处: 博客园 马瘦风的博客\n您的支持是对博主的极大鼓励, 感谢您的阅读.\n本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.\n ","description":"","id":12,"section":"posts","tags":["java","jdk"],"title":"你安装的是Oracle JDK还是OpenJDK?","uri":"https://yichenlove.github.io/posts/javajdk/"},{"content":"效果图 安装iTem2 安装 1 2 3  $ brew tap caskroom/cask # 首次安装需执行该条命令 $ brew cask install iterm2 # 安装iterm2   打开iterm2，检查Report Terminal Type的设定，设为xterm-256color,就可在terminal看到漂亮的颜色\n修改iTerm2的color scheme Over 200 terminal color schemes\n1  git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git # 克隆整个仓库    打开iterm2 快捷键 CMD+i (⌘+i) 点击 Colors 选择 Color Presets 选择Import 找到克隆下来的 .itermcolors 文件中的 scheme(s) ，选择喜欢的配色导入 再次点击 Color Presets 选中导入的color scheme  安装Nerd Fonts 使用的theme中有很多小图标，需要使用支持这些图标的icon font，这类字体称为powerline font(plus版的支持更多图标的称为：nerd font)\n没有安装icon font的界面：\n安装 Nerd-fonts: https://github.com/ryanoasis/nerd-fonts#font-installation\n安装方法: https://github.com/ryanoasis/nerd-fonts#option-4-homebrew-fonts\n1 2  brew tap caskroom/fonts brew cask install font-hack-nerd-font   查看刚刚安装的文件 1 2  cd ~/Library/Fonts ls   打开iterm2，设置字体 1  iTerm2 -\u0026gt; Preferences -\u0026gt; Profiles -\u0026gt; Text -\u0026gt; Font -\u0026gt; Change Font   注：如果切换字体，iterm2无法正常运行，可能是同一字型有重复版本问题，解决方法：\n1  打开Font Book.app -\u0026gt;选择该字体 -\u0026gt; 选择自动解决版本问题   安装zsh 1  brew install zsh   设置zsh为默认：\n1 2  sudo sh -c \u0026#34;echo $(which zsh) \u0026gt;\u0026gt; /etc/shells\u0026#34; chsh -s $(which zsh)   bash切换到zsh\n1  chsh -s /bin/zsh   安裝 oh-my-zsh 1  sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34;   切换内建主题\n1 2 3  cd ~ vim ~/.zshrc ZSH_THEME=”agnoster” # 将robbyrussell--\u0026gt;agnoster   执行以下指令生效\n1  exec $SHELL # 或 source .zshrc   安装 powerlevel9k powerlevel9k\n1 2 3  brew tap sambadevi/powerlevel9k brew install powerlevel9k   powerlevel9k不是 oh-my-zsh 內建的 theme,需另外下载\n1  $ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k   编辑.zshrc\n1 2 3 4 5 6 7 8 9 10 11  # 设置zsh主题 ZSH_THEME=\u0026#34;powerlevel9k/powerlevel9k\u0026#34; # 设置左边显示的内容 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs) # \u0026lt;= left prompt 设了 \u0026#34;dir\u0026#34; 即文件、进入有写入权限的文件夹则提示、vcs # command line 右边想显示的内容 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(time) # \u0026lt;= right prompt 设了 \u0026#34;time\u0026#34; 即时间 # 显示git的图标 POWERLEVEL9K_MODE=\u0026#39;nerdfont-complete\u0026#39;   更多配置参考：https://github.com/bhilburn/powerlevel9k#available-prompt-segments\n快速配置，可参考 https://github.com/xqlip/lin_terminal.git\n推荐安装的套件 Zsh-autosuggestions:https://github.com/zsh-users/zsh-autosuggestions\n参考链接： https://medium.com/the-code-review/nerd-fonts-how-to-install-configure-and-remove-programming-fonts-on-a-mac-178833b9daf3\nhttps://medium.com/the-code-review/make-your-terminal-more-colourful-and-productive-with-iterm2-and-zsh-11b91607b98c\nhttps://medium.com/the-code-review/powerlevel9k-personalise-your-prompt-for-any-programming-language-68974c127c63\nhttps://medium.com/@h86991868/%E7%9C%8B%E8%86%A9%E4%BA%86%E4%B8%80%E6%88%90%E4%B8%8D%E8%AE%8A%E7%9A%84%E5%B0%8F%E9%BB%91%E7%AA%97-%E6%94%B9%E7%94%A8iterm2-oh-my-zsh%E5%90%A7-cc2b0683acb\n","description":"","id":13,"section":"posts","tags":null,"title":"iTem2 + oh-my-zsh 打造Mac上好用的终端","uri":"https://yichenlove.github.io/posts/ohmyzsh/"},{"content":"协程在unity中是一个很常用的方法，我们可以利用协程使代码看起来更连贯，易于理解。xlua在示例6中提供了一个协程的示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  local util = require \u0026#39;xlua.util\u0026#39; local gameobject = CS.UnityEngine.GameObject(\u0026#39;Coroutine_Runner\u0026#39;) CS.UnityEngine.Object.DontDestroyOnLoad(gameobject) local cs_coroutine_runner = gameobject:AddComponent(typeof(CS.Coroutine_Runner)) local function async_yield_return(to_yield, cb) cs_coroutine_runner:YieldAndCallback(to_yield, cb) end return { yield_return = util.async_to_sync(async_yield_return) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  local util = require \u0026#39;xlua.util\u0026#39; local yield_return = (require \u0026#39;cs_coroutine\u0026#39;).yield_return local co = coroutine.create(function() print(\u0026#39;coroutine start!\u0026#39;) local s = os.time() yield_return(CS.UnityEngine.WaitForSeconds(3)) print(\u0026#39;wait interval:\u0026#39;, os.time() - s) local www = CS.UnityEngine.WWW(\u0026#39;http://www.qq.com\u0026#39;) yield_return(www) if not www.error then print(www.bytes) else print(\u0026#39;error:\u0026#39;, www.error) end end) assert(coroutine.resume(co))   利用这个示例我们可以实现协程的一些功能，比如服务器列表获取，资源下载等。但是，随着项目的推进，我们发现，这个协程和我们在unity中使用的协程是不一样的，我们无法中断它。相信很多人都遇到了这个问题，为了解决这个问题，我们需要换一种思路来实现。\n在前面的设计中，我们将c#端的LuaBehaviour注入到了lua端，这以为着我们可以直接利用这个注入变量调用c#端的StartCoroutine函数，能调用到这个函数，问题就直接解决了。\n但是，进阶这会发现好像并不能运行，这是因为Lua端的函数仅仅是个普通函数，而协程StartCoroutine要求的函数是要IEnumerator，这意味着我们需要构造出一个IEnumerator来，在官方文档《hotfix.md》里，有一节是“Unity协程”\n 通过util.cs_generator可以用一个function模拟一个IEnumerator，在里头用coroutine.yield，就类似C#里头的yield return。比如下面的C#代码和对应的hotfix代码是等同效果的\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  ~~~csharp [XLua.Hotfix] public class HotFixSubClass : MonoBehaviour { IEnumerator Start() { while (true) { yield return new WaitForSeconds(3); Debug.Log(\u0026#34;Wait for 3 seconds\u0026#34;); } } } ~~~ ~~~csharp luaenv.DoString(@\u0026#34; local util = require \u0026#39;xlua.util\u0026#39; xlua.hotfix(CS.HotFixSubClass,{ Start = function(self) return util.cs_generator(function() while true do coroutine.yield(CS.UnityEngine.WaitForSeconds(3)) print(\u0026#39;Wait for 3 seconds\u0026#39;) end end end; }) \u0026#34;); ~~~   至此，我们可以构造出IEnumerator，然后调用MonoBehaviour 的StartCoroutine函数来实现unity侧特性的协程，这种协程是可以通过StopCoroutine来中断的。\n","description":"","id":15,"section":"posts","tags":["unity","xlua","lua"],"title":" XLua框架——lua协程实现","uri":"https://yichenlove.github.io/posts/xluacoroutine/"},{"content":"详解 HTTP 协议 思维导图预览\n一张图带你看完本篇文章\n一、概述 1.计算机网络体系结构分层 计算机网络体系结构分层\n2.TCP/IP 通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：\nTCP/IP 通信传输流\n 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。  如下图所示：\nHTTP 请求\n在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1版本）展开。\n HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\nHTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。\n我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。\n 二、HTTP 工作过程 HTTP请求响应模型\nHTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：\n 建立 TCP 连接\n在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80； 客户端向服务器发送请求命令\n一旦建立了TCP连接，客户端就会向服务器发送请求命令；\n例如：GET/sample/hello.jsp HTTP/1.1 客户端发送请求头信息\n客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送； 服务器应答\n客户端向服务器发出请求后，服务器会客户端返回响应；\n例如： HTTP/1.1 200 OK\n响应的第一部分是协议的版本号和响应状态码 服务器返回响应头信息\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档； 服务器向客户端发送数据\n服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据； 服务器关闭 TCP 连接\n一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。  三、HTTP 协议基础 1.通过请求和响应的交换达成通信 应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。\n2.HTTP 是不保存状态的协议 HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。\n可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。\n3.使用 Cookie 的状态管理 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\nCookie 的流程\n4.请求 URI 定位资源 HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。\n5.告知服务器意图的 HTTP 方法（HTTP/1.1） HTTP 方法\n6.持久连接 HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。\n为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。**其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。**在 HTTP/1.1 中，所有的连接默认都是持久连接。\n7.管线化 持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。\n比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。\n四、HTTP 协议报文结构 1.HTTP 报文 用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\n2.HTTP 报文结构 HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：\nHTTP 报文结构\n2.1请求报文结构 请求报文结构\n请求报文的首部内容由以下数据组成：\n 请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本。 首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）  请求报文的示例，如下：\n请求报文示例\n2.2响应报文结构 响应报文结构\n响应报文的首部内容由以下数据组成：\n 状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。 首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）  响应报文的示例，如下：\n响应报文示例\n五、HTTP 报文首部之请求行、状态行 1.请求行 举个栗子，下面是一个 HTTP 请求的报文：\nGET /index.htm HTTP/1.1 Host: sample.com 其中，下面的这行就是请求行，\nGET /index.htm HTTP/1.1  开头的 GET 表示请求访问服务器的类型，称为方法； 随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI； 最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。  综合来看，大意是请求访问某台 HTTP 服务器上的 /index.htm 页面资源。\n2.状态行 同样举个栗子，下面是一个 HTTP 响应的报文：\n1 2 3 4 5 6 7  HTTP/1.1 200 OK Date: Mon, 10 Jul 2017 15:50:06 GMT Content-Length: 256 Content-Type: text/html \u0026lt;html\u0026gt; ...   其中，下面的这行就是状态行，\nHTTP/1.1 200 OK  开头的 HTTP/1.1 表示服务器对应的 HTTP 版本； 紧挨着的 200 OK 表示请求的处理结果的状态码和原因短语。  六、HTTP 报文首部之首部字段（重点分析） 1.首部字段概述 先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。\n在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。\n2.首部字段结构  HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。 另外，字段值对应单个 HTTP 首部字段可以有多个值。 当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。     首部字段名 冒号 字段值     Content-Type ： text/html   Keep-Alive ： timeout=30, max=120    3.首部字段类型 首部字段根据实际用途被分为以下4种类型：\n   类型 描述     通用首部字段 请求报文和响应报文两方都会使用的首部   请求首部字段 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息   响应首部字段 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。   实体首部字段 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。    4.通用首部字段（HTTP/1.1）    首部字段名 说明     Cache-Control 控制缓存的行为   Connection 逐挑首部、连接的管理   Date 创建报文的日期时间   Pragma 报文指令   Trailer 报文末端的首部一览   Transfer-Encoding 指定报文主体的传输编码方式   Upgrade 升级为其他协议   Via 代理服务器的相关信息   Warning 错误通知    4.1 Cache-Control 通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。\n4.1.1 可用的指令一览 可用的指令按请求和响应分类如下：\n缓存请求指令\n   指令 参数 说明     no-cache 无 强制向服务器再次验证   no-store 无 不缓存请求或响应的任何内容   max-age = [秒] 必需 响应的最大Age值   max-stale( =[秒]) 可省略 接收已过期的响应   min-fresh = [秒] 必需 期望在指定时间内的响应仍有效   no-transform 无 代理不可更改媒体类型   only-if-cached 无 从缓存获取资源   cache-extension - 新指令标记（token）    缓存响应指令\n   指令 参数 说明     public 无 可向任意方提供响应的缓存   private 可省略 仅向特定用户返回响应   no-cache 可省略 缓存前必须先确认其有效性   no-store 无 不缓存请求或响应的任何内容   no-transform 无 代理不可更改媒体类型   must-revalidate 无 可缓存但必须再向源服务器进行确认   proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认   max-age = [秒] 必需 响应的最大Age值   s-maxage = [秒] 必需 公共缓存服务器响应的最大Age值   cache-extension - 新指令标记（token）    4.1.2 表示能否缓存的指令 public 指令\nCache-Control: public\n当指定使用 public 指令时，则明确表明其他用户也可利用缓存。\nprivate 指令\nCache-Control: private\n当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。\nno-cache 指令\nCache-Control: no-cache\n 使用 no-cache 指令是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。 如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。  Cache-Control: no-cache=Location\n由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。\nno-store 指令\nCache-Control: no-store\n当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。\n注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。\n4.1.3 指定缓存期限和认证的指令 s-maxage 指令\nCache-Control: s-maxage=604800（单位：秒）\n s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。  max-age 指令\nCache-Control: max-age=604800（单位：秒）\n 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。 应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。  min-fresh 指令\nCache-Control: min-fresh=60（单位：秒）\nmin-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。\nmax-stale 指令\nCache-Control: max-stale=3600（单位：秒）\n 使用 max-stale 可指示缓存资源，即使过期也照常接收。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。  only-if-cached 指令\nCache-Control: only-if-cached\n表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。\nmust-revalidate 指令\nCache-Control: must-revalidate\n使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。\nproxy-revalidate 指令\nCache-Control: proxy-revalidate\nproxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。\nno-transform 指令\nCache-Control: no-transform\n使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。\n4.1.4 Cache-Control 扩展 Cache-Control: private, community=\u0026quot;UCI\u0026quot;\n通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。\n4.2 Connection Connection 首部字段具备以下两个作用：\n控制不再转发的首部字段\nConnection: Upgrade\n在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。\n管理持久连接\nConnection: close\nHTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。\nConnection: Keep-Alive\nHTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。\n4.3 Date 表明创建 HTTP 报文的日期和时间。\nDate: Mon, 10 Jul 2017 15:50:06 GMT\nHTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。\n4.4 Pragma Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。\nPragma: no-cache\n 该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：  Cache-Control: no-cache Pragma: no-cache 4.5 Trailer Trailer: Expires\n首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。\n4.6 Transfer-Encoding Transfer-Encoding: chunked\n 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。  4.7 Upgrade Upgrade: TSL/1.0\n用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。\n4.8 Via Via: 1.1 a1.sample.com(Squid/2.7)\n 为了追踪客户端和服务器端之间的请求和响应报文的传输路径。 报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。 首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。  4.9 Warning 该首部字段通常会告知用户一些与缓存相关的问题的警告。\nWarning 首部字段的格式如下：\nWarning：[警告码][警告的主机:端口号] \u0026quot;[警告内容]\u0026quot;([日期时间])\n最后的日期时间可省略。\nHTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。\n   警告码 警告内容 说明     110 Response is stale(响应已过期) 代理返回已过期的资源   111 Revalidation failed(再验证失败) 代理再验证资源有效性时失败（服务器无法到达等原因）   112 Disconnection operation(断开连接操作) 代理与互联网连接被故意切断   113 Heuristic expiration(试探性过期) 响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)   199 Miscellaneous warning(杂项警告) 任意的警告内容   214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时   299 Miscellaneous persistent warning(持久杂项警告) 任意的警告内容    5. 请求首部字段（HTTP/1.1）    首部字段名 说明     Accept 用户代理可处理的媒体类型   Accept-Charset 优先的字符集   Accept-Encoding 优先的内容编码   Accept-Language 优先的语言（自然语言）   Authorization Web认证信息   Expect 期待服务器的特定行为   From 用户的电子邮箱地址   Host 请求资源所在服务器   If-Match 比较实体标记（ETag）   If-Modified-Since 比较资源的更新时间   If-None-Match 比较实体标记（与 If-Macth 相反）   If-Range 资源未更新时发送实体 Byte 的范围请求   If-Unmodified-Since 比较资源的更新时间(与 If-Modified-Since 相反)   Max-Forwards 最大传输逐跳数   Proxy-Authorization 代理服务器要求客户端的认证信息   Range 实体的字节范围请求   Referer 对请求中 URI 的原始获取方   TE 传输编码的优先级   User-Agent HTTP 客户端程序的信息    5.1 Accept Accept: text/html, application/xhtml+xml, application/xml; q=0.5\n Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。 若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。  5.2 Accept-Charset Accept-Charset: iso-8859-5, unicode-1-1; q=0.8\nAccept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。\n5.3 Accept-Encoding Accept-Encoding: gzip, deflate\nAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。\n5.4 Accept-Language Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3\n告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。\n5.5 Authorization Authorization: Basic ldfKDHKfkDdasSAEdasd==\n告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。\n5.6 Expect Expect: 100-continue\n告知服务器客户端期望出现的某种特定行为。\n5.7 From From: Deeson_Woo@163.com\n告知服务器使用用户代理的电子邮件地址。\n5.8 Host Host: www.jianshu.com\n 告知服务器，请求的资源所处的互联网主机和端口号。 Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。 若服务器未设定主机名，那直接发送一个空值即可 Host: 。  5.9 If-Match 形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。\nIf-Match: \u0026quot;123456\u0026quot;\n 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。 还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。  5.10 If-Modified-Since If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT\n 首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。 它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。  5.11 If-None-Match If-None-Match: \u0026quot;123456\u0026quot;\n首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。\n5.12 If-Range If-Range: \u0026quot;123456\u0026quot;\n 首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。 下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。  5.13 If-Unmodified-Since If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT\n首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。\n5.14 Max-Forwards Max-Forwards: 10\n通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。\n5.15 Proxy-Authorization Proxy-Authorization: Basic dGlwOjkpNLAGfFY5\n 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。  5.16 Range Range: bytes=5001-10000\n 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。  5.17 Referer Referer: http://www.sample.com/index.html\n首部字段 Referer 会告知服务器请求的原始资源的 URI。\n5.18 TE TE: gzip, deflate; q=0.5\n 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers  5.19 User-Agent User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101\n 首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。 由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。  6. 响应首部字段（HTTP/1.1）    首部字段名 说明     Accept-Ranges 是否接受字节范围请求   Age 推算资源创建经过时间   ETag 资源的匹配信息   Location 令客户端重定向至指定 URI   Proxy-Authenticate 代理服务器对客户端的认证信息   Retry-After 对再次发起请求的时机要求   Server HTTP 服务器的安装信息   Vary 代理服务器缓存的管理信息   WWW-Authenticate 服务器对客户端的认证信息    6.1 Accept-Ranges Accept-Ranges: bytes\n 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。  6.2 Age Age: 1200\n 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。  6.3 ETag ETag: \u0026quot;usagi-1234\u0026quot;\n 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。 另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。 ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/\u0026quot;usagi-1234\u0026quot;。  6.4 Location Location: http://www.sample.com/sample.html\n 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。  6.5 Proxy-Authenticate Proxy-Authenticate: Basic realm=\u0026quot;Usagidesign Auth\u0026quot;\n 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。  6.6 Retry-After Retry-After: 180\n 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。 字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。  6.7 Server Server: Apache/2.2.6 (Unix) PHP/5.2.5\n首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。\n6.8 Vary Vary: Accept-Language\n 首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。  6.9 WWW-Authenticate WWW-Authenticate: Basic realm=\u0026quot;Usagidesign Auth\u0026quot;\n首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。\n7. 实体首部字段（HTTP/1.1）    首部字段名 说明     Allow 资源可支持的 HTTP 方法   Content-Encoding 实体主体适用的编码方式   Content-Language 实体主体的自然语言   Content-Length 实体主体的大小（单位：字节）   Content-Location 替代对应资源的 URI   Content-MD5 实体主体的报文摘要   Content-Range 实体主体的位置范围   Content-Type 实体主体的媒体类型   Expires 实体主体过期的日期时间   Last-Modified 资源的最后修改日期时间    7.1 Allow Allow: GET, HEAD\n 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。 当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。  7.2 Content-Encoding Content-Encoding: gzip\n 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。 主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。  7.3 Content-Language Content-Language: zh-CN\n首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。\n7.4 Content-Length Content-Length: 15000\n首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。\n7.5 Content-Location Content-Location: http://www.sample.com/index.html\n首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。\n7.6 Content-MD5 Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==\n首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。\n7.7 Content-Range Content-Range: bytes 5001-10000/10000\n针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。\n7.8 Content-Type Content-Type: text/html; charset=UTF-8\n首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。\n7.9 Expires Expires: Mon, 10 Jul 2017 15:50:06 GMT\n 首部字段 Expires 会将资源失效的日期告知客户端。 缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。  7.10 Last-Modified Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT\n首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。\n8. 为 Cookie 服务的首部字段    首部字段名 说明 首部类型     Set-Cookie 开始状态管理所使用的 Cookie 信息 响应首部字段   Cookie 服务器接收到的 Cookie 信息 请求首部字段    8.1 Set-Cookie Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;\n下面的表格列举了 Set-Cookie 的字段值。\n   属性 说明     NAME=VALUE 赋予 Cookie 的名称和其值（必需项）   expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）   path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）   domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）   Secure 仅在 HTTPS 安全通信时才会发送 Cookie   HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问    8.1.1 expires 属性  Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。  8.1.2 path 属性 Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。\n8.1.3 domain 属性  通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。  8.1.4 secure 属性 Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。\n8.1.5 HttpOnly 属性  Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。  8.2 Cookie Cookie: status=enable\n首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n9. 其他首部字段 HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。\n以下是最为常用的首部字段。\n9.1 X-Frame-Options X-Frame-Options: DENY\n首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：\n DENY：拒绝 SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 http://sample.com/sample.html 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）  9.2 X-XSS-Protection X-XSS-Protection: 1\n首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:\n 0 ：将 XSS 过滤设置成无效状态 1 ：将 XSS 过滤设置成有效状态  9.3 DNT DNT: 1\n首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：\n 0 ：同意被追踪 1 ：拒绝被追踪  由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。\n9.4 P3P P3P: CP=\u0026quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND\n首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。\n要进行 P3P 的设定，需按以下操作步骤进行：\n 步骤 1：创建 P3P 隐私 步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml 步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中  七、HTTP 响应状态码（重点分析） 1. 状态码概述  HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 HTTP 状态码如 200 OK ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。 不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。  2. 状态码类别     类别 原因短语     1xx Informational(信息性状态码) 接收的请求正在处理   2xx Success(成功状态码) 请求正常处理完毕   3xx Redirection(重定向状态码) 需要进行附加操作以完成请求   4xx Client Error(客户端错误状态码) 服务器无法处理请求   5xx Server Error(服务器错误状态码) 服务器处理请求出错    我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。\n3. 常用状态码解析 HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。\n3.1 200 OK 表示从客户端发来的请求在服务器端被正常处理了。\n3.2 204 No Content  代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。 一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。  3.3 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。\n3.4 301 Moved Permanently 永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。\n3.5 302 Found  临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 Found 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。  3.6 303 See Other  表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 See Other 和 302 Found 状态码有着相同的功能，但 303 See Other 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 Found 状态码有区别。  3.7 304 Not Modified  表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。 304 Not Modified 状态码返回时，不包含任何响应的主体部分。 304 Not Modified 虽然被划分到 3xx 类别中，但和重定向没有关系。  3.8 307 Temporary Redirect 临时重定向。该状态码与 302 Found 有着相同的含义。\n3.9 400 Bad Request  表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 另外，浏览器会像 200 OK 一样对待该状态码。  3.10 401 Unauthorized  表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。 另外，若之前已进行过 1 次请求，则表示用户认证失败。 返回含有 401 Unauthorized 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。  3.11 403 Forbidden 表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。\n3.12 404 Not Found 表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。\n3.13 500 Internal Server Error 表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。\n3.14 503 Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。\n八、HTTP 报文实体 1. HTTP 报文实体概述 HTTP 报文结构\n大家请仔细看看上面示例中，各个组成部分对应的内容。\n接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。\n 报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）  我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n2. 内容编码  HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。 这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。  内容编码类型：\n   编码方式 描述     gzip 表明实体采用 GNU zip 编码   compress 表明实体采用 Unix 的文件压缩程序   deflate 表明实体采用 zlib 的格式压缩的   identity 表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式    3. 传输编码 内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。\n传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。\n内容编码和传输编码的对比\n4. 分块编码 分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。\n分块编码与持久连接\n若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。\n当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。\n分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。\n来看看一个分块编码的报文示例：\n分块编码的报文\n5.多部分媒体类型 MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。\n相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。\n多部分对象集合包含的对象如下：\n multipart/form-data：在 Web 表单文件上传时使用。 multipart/byteranges：状态码 206 Partial Content 响应报文包含了多个范围的内容时使用。  6. 范围请求 假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。\n有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：\nGET /bigfile.html HTTP/1.1 Host: www.sample.com Range: bytes=20224- ··· 实体范围请求示例\n上面示例中，客户端请求的是文档开头20224字节之后的部分。\n九、与 HTTP 协作的 Web 服务器 HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：代理、缓存、网关、隧道、Agent 代理。\n1.代理 代理\nHTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。\n出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。\n2. 缓存 浏览器第一次请求：\n浏览器第一次请求\n浏览器再次请求：\n浏览器再次请求\nWeb 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。\n3. 网关 HTTP / FTP 网关\n网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。\n4. 隧道 HTTP/SSL 隧道\n隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。\nHTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。\n5. Agent 代理 自动搜索引擎“网络蜘蛛”\nAgent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。\n后续 参考文章 一篇文章带你详解 HTTP 协议（网络协议篇一）\n学习资料**  《HTTP权威指南》 《图解HTTP》  ","description":"","id":16,"section":"posts","tags":["http"],"title":"详解 HTTP 协议","uri":"https://yichenlove.github.io/posts/http/"},{"content":"熟悉 TCP/IP 协议 一张思维导图\n一图看完本文\n一、 计算机网络体系结构分层 计算机网络体系结构分层\n计算机网络体系结构分层\n不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。\n二、 TCP/IP 基础 1. TCP/IP 的具体含义 从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。\n互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。\n网际协议群\n2. 数据包 包、帧、数据包、段、消息\n以上五个术语都用来表述数据的单位，大致区分如下：\n 包可以说是全能性术语； 帧用于表示数据链路层中包的单位； 数据包是 IP 和 UDP 等网络层以上的分层中包的单位； 段则表示 TCP 数据流中的信息； 消息是指应用协议中数据的单位。  每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。\n数据包首部\n网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。\n3. 数据处理流程 下图以用户 a 向用户 b 发送邮件为例子：\n数据处理流程\n ① 应用程序处理\n首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；\n编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。 ② TCP 模块的处理\nTCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。 ③ IP 模块的处理\nIP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。 ④ 网络接口（以太网驱动）的处理\n从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。 ⑤ 网络接口（以太网驱动）的处理\n主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。\n如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。 ⑥ IP 模块的处理\nIP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。\n另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。 ⑦ TCP 模块的处理\n在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。 ⑧ 应用程序的处理\n接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。  三、传输层中的 TCP 和 UDP TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。\n TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。 UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。 TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。  1. 端口号 数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。\n1.1 根据端口号识别应用 一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。\n通过端口号识别应用\n1.2 通过 IP 地址、端口号、协议号进行通信识别  仅凭目标端口号识别某一个通信是远远不够的。  通过端口号、IP地址、协议号进行通信识别\n ① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。 ③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。 此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。  1.3 端口号的确定  标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。  1.4 端口号与协议  端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。  2. UDP  UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。 此外，传输途中出现丢包，UDP 也不负责重发。 甚至当包的到达顺序出现乱序时也没有纠正的功能。 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。 UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。  3. TCP  TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。  3.1 三次握手（重点）  TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。  下面来看看三次握手的流程图：\n三次握手\n 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。  3.2 四次挥手（重点）  四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。  下面来看看四次挥手的流程图：\n四次挥手\n 中断连接端可以是客户端，也可以是服务器端。 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说\u0026quot;我客户端没有数据要发给你了\u0026quot;，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。  上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，\n具体流程如下图：\n同时挥手\n3.3 通过序列号与确认应答提高可靠性  在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。 序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。  序列号和确认应答\n3.4 重发超时的确定  **重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。**如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。 TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。 此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。  3.5 以段为单位发送数据  在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。 TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。 MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。  3.6 利用窗口控制提高速度   TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。\n  为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：\n  窗口控制\n 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。  3.7 滑动窗口控制 滑动窗口\n 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。  3.8 窗口控制中的重发控制 在使用窗口控制中， 出现丢包一般分为两种情况：\n ① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：  部分确认应答丢失\n ② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。  高速重发控制\n四、网络层中的 IP 协议  IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。 网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。 IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。  1. IP 地址 1.1 IP 地址概述  在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。 IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：     28 28 28 28      10101100 00010100 00000001 00000001 （2进制）   10101100. 00010100. 00000001. 00000001 （2进制）   172. 20. 1. 1 （10进制）    1.2 IP 地址由网络和主机两部分标识组成  如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。  IP地址的主机标识\n 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。  IP地址的网络标识\n1.3 IP 地址的分类  IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。 **A 类 IP 地址是首位以 “0” 开头的地址。**从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。 **B 类 IP 地址是前两位 “10” 的地址。**从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。 **C 类 IP 地址是前三位为 “110” 的地址。**从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。 **D 类 IP 地址是前四位为 “1110” 的地址。**从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。  1.4 广播地址  广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。  1.5 IP 多播   多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。\n  相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：\nIP 多播\n  多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。\n  此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。\n  1.6 子网掩码  现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。 对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：     IP 地址 172. 20. 100. 52     子网掩码 255. 255. 255. 192          网络地址 172. 20. 100. 0   子网掩码 255. 255. 255. 192          广播地址 172. 20. 100. 63   子网掩码 255. 255. 255. 192     第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：     IP 地址 172. 20. 100. 52 / 26     网络地址 172. 20. 100. 0 / 26   广播地址 172. 20. 100. 63 / 26     另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。  2. 路由  发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。 IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。  2.1 IP 地址与路由控制  IP 地址的网络地址部分用于进行路由控制。 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。  路由控制表与 IP 包发送\n3. IP 分包与组包  每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。  3.1 路径 MTU 发现  分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。  4. IPv6  IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。  4.1 IPv6 的特点  IP 得知的扩大与路由控制表的聚合。 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。 多播、Mobile IP 成为扩展功能。  4.2 IPv6 中 IP 地址的标记方法  一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。  4.3 IPv6 地址的结构  IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。     未定义 0000 \u0026hellip; 0000（128比特） ：：/ 128     环回地址 0000 \u0026hellip; 0001（128比特） ：：1 / 128   唯一本地地址 1111 110 FC00：/ 7   链路本地单播地址 1111 1110 10 FE80：：/ 10   多播地址 1111 1111 FF00：：/ 8   全局单播地址 （其他）     4.4 全局单播地址  全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。  全局单播地址\n4.5 链路本地单播地址  链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。  链路本地单播地址\n4.6 唯一本地地址  唯一本地地址是不进行互联网通信时所用的地址。 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。 L 通常被置为 1 全局 ID 的值随机决定 子网 ID 是指该域子网地址 接口 ID 即为接口的 ID  唯一本地地址\n4.7 IPv6 分段处理  IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。 IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。  4.8 IP 首部（暂略） 5. IP 协议相关技术  IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。  5.1 DNS  我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。  5.2 ARP  只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。 ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。 RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。  5.3 ICMP  ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。 IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。  5.4 DHCP  如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。 DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。  5.5 NAT  NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。 NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。  5.6 IP 隧道 夹着 IPv4 网络的两个 IPv6 网络\n 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。 IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。  后续 参考文章 一篇文章带你熟悉 TCP/IP 协议（网络协议篇二\n学习资料  《TCP/IP 详解》 《图解 TCP/IP》  ","description":"","id":17,"section":"posts","tags":["TCP/IP"],"title":"TCP/IP 协议","uri":"https://yichenlove.github.io/posts/tcpip/"},{"content":"cocos creator 右键菜单，除了创建组件，effect material是什么？\n纹理：\n 关于Material:  threejs是js基于webgl的一个3D图形库 这里有个对Material很好的描述 threejs的接口都是基于Material + Geometry来创建一个现实对象 对于2d 3d显示对象，原理理应是类似的 cocos只是对sprite的封装隐藏细节 threejs对Material + Geometry接口更加GPU友好 https://segmentfault.com/a/1190000014639067  关于Effect:  Material是怎么来的？ 渲染管线：  cocos creator 里面的shader怎么和cocos2d-x里面的不一样  根上都是顶点着色器和片段着色器的  yaml格式是什么?  https://docs.cocos.com/creator3d/manual/zh/material-system/yaml-101.html 内置变量：https://docs.cocos.com/creator3d/manual/zh/material-system/builtin-shader-uniforms.html\n","description":"","id":18,"section":"posts","tags":["cocos creator","glsl"],"title":"cocos creator glsl","uri":"https://yichenlove.github.io/posts/crea_mf4/"},{"content":"已知问题跟进： cc_scenesize值没有初始化，所以始终是默认值[0,0] 给力的glsl编辑器： https://thebookofshaders.com/edit.php 一本通俗易懂的入门书: https://thebookofshaders.com/ 常用概念进阶 1.Noise 噪声 https://www.jianshu.com/p/35364a5e6e1b ","description":"","id":19,"section":"posts","tags":["cocos creator","Material Effect"],"title":"cocos creator Material Effect梳理（三）","uri":"https://yichenlove.github.io/posts/crea_mf3/"},{"content":"cocos creator 应该先带⼀个glsl基础教程https://www.jianshu.com/p/43aaff0b6226（暂定后⾯这个放到前⾯充当梳理⼆， 本篇实际是梳理三）\n实际开始搬运，有⼀些细节问题我们需要注意\nCCEeffect⽂件字段理解描述 1.Properties\n关于passes所有参数的各字段的含义，我们看⽂档\nhttps://docs.cocos.com/creator3d/manual/zh/material-system/pass-parameter-list.html\n⾥⾯最常⽤的应该就是*properties这个字段\n这⾥添加的都是统⼀常量，粗糙理解就是我们从外部传⼊的⾃定义的变量都显示在*属性检查器*这⾥\n* 注意这⾥的s_offset变量\n*更改的时候随时注意点击应⽤，cocos\ncreator操作有点违和，注意时刻点击保存特效。\nshadow.effect\nshadow.effect\n直观理解，我们想外部设置阴影的offset，shadow.effect⾥⾯最容易直观说明。\nCocos Creator封装 1.includ机制\n当前shader使⽤的语⾔是glsl 300es\n这个语⾔⼜⼀些特点相对于基础理解的glsl语⾔像C，glsl 300 es还有更⾼级的特点。\n详情⻅：\nhttps://docs.cocos.com/creator3d/manual/zh/material-system/effect-syntax.html\n⽂档内的Shader ⽚段\ninclude 应该是我们应该最常⽤和最应该理解的机制。\n看完上⾯描述，我们这么理解：\n* cocos creator⾥⾯已经写了⼀坨变量及函数，要⽤就需要include⾃⼰封装的东⻄，也可以写⼀个chunk 后⾯其他shader内可以直接include 使⽤\n我们最常⽤的cc_time cc_scenesize这些和渲染表象息息相关的，我们可以直接通过include后⽤，不⽤⼀直从外部传了。（理解动态最常⽤的变量cc_time,很多实现是通过外部脚本update函数内，给material传当前时间来作为变量，太累了...还有性能耗损）\n2.预处理宏定义（todo）\n3.Macro(todo )\n4.ubo内存处理\n我们⼀定要注意这⾥：\n*每个元素size不能⼩于vec4\n我们搬运的过程中，使⽤内置变量如cc_time使，按理解总会觉得cc_time是⼀个int或者float，实际本身应为上述规定，我们使⽤cc_time的时候实际使⽤是cc_time.x\n搬运实例\n2d基础的云朵效果\n吐槽⼀下，cocos官⽅对⾃⼰的shader效果的demo,也不过是shadertoy搬了两个...\ncloud.effect\ncloud.effect\n搬运⽐对shadertoy内的变量和 cocos creator内的变量都到底有什么不同\n","description":"","id":20,"section":"posts","tags":["cocos creator","Material Effect"],"title":"cocos creator Material Effect梳理（⼆）","uri":"https://yichenlove.github.io/posts/crea_mf2/"},{"content":"cocos creator Material Effect梳理（⼀）\ncocos creator\n右键菜单，除了创建组件，Effect Material是什么？\n* 什么是Material(纹理)？:\n```\nthreejs是js基于webgl的⼀个3D图形库\nthreejs对⾃⼰是引擎内Material的概念，这⾥有个对Material很好的描述\n⻚⾯内包含了\n* 什么是Material\n* threejs对⾃⼰内置的⼏种基础Material的描述\n⼀个⼀个看下去，看到最后.\u0026hellip;\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;5.086111111111111in\u0026rdquo;}\n...\nPhone Material\nLambert Material\nSprite Material\n...\n?!\nSpriteMaterial有点眼熟啊\n先放下Material是什么不管，我们⼀起回顾下如何创建⼀个显示对象：\n* cocos\n基于new Sprite 来创建⼀个显示对象\n```\nlet sp = new Sprite(\u0026quot;xxx\u0026quot;)\n```\n* threejs\n基于准备好材质和⼏何体，来拼接成⼀个显示对象\n```\nvar material = new THREE.MeshPhongMaterial({map: map},\nside:THREE.DoubleSide);\nvar geome = new THREE.SphereBufferGeometry(10, 10, 10)\n//我就是显示对象\nvar obj = new THREE.Mesh (geome, material);\nscene.add(obj)\n``\n⽐较下我们可以粗理解：\nnew Sprite () 和new THREE.Mesh()都是创建对象，前者隐藏了细节，\n后者更GPU友好。\n我们想在转头看Material，不就是为了创建⼀个*⾮默认显示Material的显示对象。\n* 关于Effect:\n```\nMaterial是怎么来的？先重温下Opengl渲染管线 关注Vertex Shader ,Fragment\nShader\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;8.493055555555555in\u0026rdquo;}\n我们同时回顾下刚才threejs看Material⾥⾯描述的⼏种常⻅Material\n{width=\u0026ldquo;6.304166666666666in\u0026rdquo;\nheight=\u0026ldquo;6.993055555555555in\u0026rdquo;}\n等下...\nSprite和 Phone 是不是有点眼熟\n{width=\u0026ldquo;2.2916666666666665in\u0026rdquo;\nheight=\u0026ldquo;1.3125in\u0026rdquo;}\n{width=\u0026ldquo;2.4791666666666665in\u0026rdquo;\nheight=\u0026ldquo;2.7930555555555556in\u0026rdquo;}\n.\u0026hellip;\n是的 都是⼀样的东⻄\n两个引擎都是使⽤vexshader + fragshader + 渲染⽅式配置\n创建了⼀个Material来的\n* cocos creator⾥⾯的Effect⽂件就是为了创建Material来的\u0026lt;vexshader +\nfragshader + 渲染\n⽅式配置\\⽂件\n* cocos\ncreator⾥⾯的Materialt⽂件可以赋予⼀个sprite材质，⽆纹理可直接决定表现⽅式，有纹理则是使⽤纹理\n与Material对纹理的处理共同决定表现⽅式。\n```\n* cocos creator ⾥⾯的shader怎么和cocos2d-x⾥⾯的不⼀样\n```\n根上都是处理vexshader + fragshader + 渲染⽅式配置\ncocos2d-x处理的⽅式全部是代码实现的，vexshader +\nfragshader都是单独的资源⽂件，渲染\n⽅式配置则是提供接⼝来实现\ncocos creator 则是统⼀成了⼀个Effect⽂件，⽂件格式是yaml\n什么是yaml?\n就是⼀个可序列化的配置，理解成⾼级json即可，go python\n等都有对应的解析库 类似 yaml.decode\n上百科：\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;17.15277777777778in\u0026rdquo;}\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;17.15277777777778in\u0026rdquo;}\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;17.15277777777778in\u0026rdquo;}\n其实就是⽤了个配置表包起来了。。。\n```\n好了 我们可以⽤来做什么...\n当然是从来不⽣产代码，只做代码的搬运⼯...上⼯地\n这⾥都是基于webgl能使⽤的shader的在线显示，都是采⽤glsl语⾔来的，和Unity不⼀样，unity也包裹了⼀层，当\n然根上还是可以⽤glsl的，所以，⽤什么引擎，只要是opengl渲染的，都可以上来看看glsl的实现搬运⼀把\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;2.9499989063867016in\u0026rdquo;}\n我们关注⼏个地⽅：\n* 着⾊器输⼊\n这⾥是webgl要渲染的时候外部传进来的变量\n对⼀个转换成cocos使⽤的变量再搬运~\n*compile\n这个是可以在线调试的，直接改代码效果微调后直接compile即时看效果美滋滋\n* compile下⽅的区域\n有些效果是基于纹理的，⼤部分是噪点纹理或具体实物材质表⾯效果的纹理。\n怎么这么多⿊框？\n{width=\u0026ldquo;5.908333333333333in\u0026rdquo;\nheight=\u0026ldquo;2.522222222222222in\u0026rdquo;}\ncocos creator 也是⽀持传⼊8张纹理之多来叠加的.\u0026hellip;.\n搬运步骤:\n1. 创建\n{width=\u0026ldquo;2.5527777777777776in\u0026rdquo;\nheight=\u0026ldquo;3.376388888888889in\u0026rdquo;}\n最好在这个路径，我们都知道glsl可能写起来⼀⼤堆⼀⼤堆，每个引擎多多少少为了复⽤，都有include机制\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;2.8027777777777776in\u0026rdquo;}\ninclude 可以导⼊别的glsl⽂件短，增加复⽤和抽象\nloadcloud 对应的Effect⽂件抄起来~\n{width=\u0026ldquo;6.461111111111111in\u0026rdquo;\nheight=\u0026ldquo;8.858332239720035in\u0026rdquo;}\n顺利替换完变量抄完，拖⼊sprite内运⾏查看效果\n{width=\u0026ldquo;4.783333333333333in\u0026rdquo;\nheight=\u0026ldquo;4.095832239720035in\u0026rdquo;}\nduang!\n","description":"","id":21,"section":"posts","tags":["cocos creator","Material Effect"],"title":"cocos creator Material Effect梳理（⼀）","uri":"https://yichenlove.github.io/posts/crea_mf/"},{"content":" apply、call  在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。\nJavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。\n先来一个栗子：\n1 2 3 4 5 6 7 8 9 10 11  function fruits() {} fruits.prototype = { color: \u0026#34;red\u0026#34;, say: function() { console.log(\u0026#34;My color is \u0026#34; + this.color); } } var apple = new fruits; apple.say(); //My color is red   但是如果我们有一个对象banana= {color : \u0026ldquo;yellow\u0026rdquo;} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：\n1 2 3 4 5  banana = { color: \u0026#34;yellow\u0026#34; } apple.say.call(banana); //My color is yellow apple.say.apply(banana); //My color is yellow   所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。\n apply、call 的区别 对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：\n1 2 3  var func = function(arg1, arg2) { };   就可以通过如下方式来调用：\n1 2  func.call(this, arg1, arg2); func.apply(this, [arg1, arg2])   其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。　JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。\n而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。\n为了巩固加深记忆，下面列举一些常用用法：\n数组之间追加 1 2 3 4  var array1 = [12 , \u0026#34;foo\u0026#34; , {name \u0026#34;Joe\u0026#34;} , -2458]; var array2 = [\u0026#34;Doe\u0026#34; , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , \u0026#34;foo\u0026#34; , {name \u0026#34;Joe\u0026#34;} , -2458 , \u0026#34;Doe\u0026#34; , 555 , 100] */   获取数组中的最大值和最小值 1 2 3  var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458  maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458   number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。\n验证是否是数组（前提是toString()方法没有被重写过） 1 2 3  function isArray(obj){ return Object.prototype.toString.call(obj) === \u0026#39;[object Array]\u0026#39; ; }   类（伪）数组使用数组方法 1  var domNodes = Array.prototype.slice.call(document.getElementsByTagName(\u0026#34;*\u0026#34;));   Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。\n但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。\n 深入理解运用apply、call 下面就借用一道面试题，来更深入的去理解下 apply 和 call 。\n定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是：\n1 2 3 4 5  function log(msg)　{ console.log(msg); } log(1); //1 log(1,2); //1   上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下：\n1 2 3 4 5  function log(){ console.log.apply(console, arguments); }; log(1); //1 log(1,2); //1 2   接下来的要求是给每一个 log 消息添加一个\u0026quot;(app)\u0026ldquo;的前辍，比如：\n1  log(\u0026#34;hello world\u0026#34;); //(app)hello world   该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样：\n1 2 3 4 5 6  function log(){ var args = Array.prototype.slice.call(arguments); args.unshift(\u0026#39;(app)\u0026#39;); console.log.apply(console, args); };    bind 详解 说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。\nMDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样：\n1 2 3 4 5 6 7 8 9 10  var foo = { bar : 1, eventBind: function(){ var _this = this; $(\u0026#39;.someClass\u0026#39;).on(\u0026#39;click\u0026#39;,function(event) { /* Act on the event */ console.log(_this.bar); //1  }); } }   由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $('.someClass').on(\u0026lsquo;click\u0026rsquo;,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：\n1 2 3 4 5 6 7 8 9  var foo = { bar : 1, eventBind: function(){ $(\u0026#39;.someClass\u0026#39;).on(\u0026#39;click\u0026#39;,function(event) { /* Act on the event */ console.log(this.bar); //1  }.bind(this)); } }   在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子：\n1 2 3 4 5 6 7 8 9  var bar = function(){ console.log(this.x); } var foo = { x:3 } bar(); // undefined var func = bar.bind(foo); func(); // 3   这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。\n有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var bar = function(){ console.log(this.x); } var foo = { x:3 } var sed = { x:4 } var func = bar.bind(foo).bind(sed); func(); //?  var fiv = { x:5 } var func = bar.bind(foo).bind(sed).bind(fiv); func(); //?   答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。\n　apply、call、bind比较 那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var obj = { x: 81, }; var foo = { getX: function() { return this.x; } } console.log(foo.getX.bind(obj)()); //81 console.log(foo.getX.call(obj)); //81 console.log(foo.getX.apply(obj)); //81   三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。\n也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。\n 再总结一下：\n apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。  ","description":"","id":22,"section":"posts","tags":["javascript"],"title":"Javascript中apply、call、bind","uri":"https://yichenlove.github.io/posts/javascripts-bind/"},{"content":"在游戏开发过程中，游戏性能是非常重要的，学会使用unity自带的profiler工具是非常必要的，以下是我从官方地址找到的进阶教程，感觉文章非常详细，于是尝试翻译。\n官方教学文档翻译，英文教程地址https://unity3d.com/cn/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window?playlist=44069\n介绍 如果我们游戏运行很慢，卡顿甚至卡死，我们就知道游戏出现了性能问题。在我们尝试修复问题之前，我们首先要知道是什么造成了这种问题。不同的问题需要不同的解决方案。如果我们尝试猜测问题或根据其他项目对游戏进行调整，这会非常浪费时间甚至会使问题变得更加糟糕。\n这个时候，我们就需要对问题进行分析。分析是在运行我们游戏的时候对各个方面进行测量。使用profiling工具，当我们游戏运行的时候，可以看到屏幕后面发生的事情并且根据这些信息跟踪造成性能问题的原因。通过查看profiling工具，我们可以测量我们修改后的结果，这样我们就可以判断我们的修复是否有效。\n在这篇文章中，我们将：\n 使用Unity自带的的Profiler工具去收集我们游戏性能差的游戏的数据。 分析这些数据并且使用分析的结构去追踪到性能问题 提供修复这些问题的链接  要让一个游戏运行顺畅是一个平衡的过程。在获得理想结果之前，我们可能要对游戏进行好几次的修改和验证。知道如何使用profiling工具去分析我们的问题意味着我们能够确定游戏的问题是什么并且知道下一步要怎么做。\n写在开始 这篇文章会帮助我们跟踪到造成Unity游戏运行缓慢、卡顿甚至卡死的位置。如果我们有其他问题，比如崩溃或图像异常，这篇文章可能不会有太大的帮助。如果我们游戏中出现了这篇文章没所提到的一些问题，可以尝试搜索Unity手册、Unity社区或Unity解答。\n如果我们对Profiler窗口或如何使用Profiler不熟悉的话，建议先看这篇文章\n对游戏性能的一个简介 帧率是衡量游戏性能的标准。游戏里面的帧跟动画的帧类似。只是游戏里面的图像被画到了屏幕。画一帧到屏幕被称为渲染一帧。帧率或帧被渲染的速度以每秒来衡量(FPS)\n现在大多数游戏都是以60FPS为目标。通常30FPS以上被认为是可以接受的，特别是对于一些对反应速度要求不高的游戏，如解谜或冒险游戏。一些游戏对帧率要求比较高，如VR，90FPS都会被嫌弃。帧率在30FPS以下，玩家体验通常会比较差，图像可能会卡顿、操作起来也很迟钝。然而，不仅仅速度重要，帧率稳定也很重要。帧率发生变对对玩家来说是很明显的。不稳定的帧率通常比稳定但是帧率低的游戏更糟糕。\n尽管帧率是谈论游戏性能经常提到，但是要尝试去改善游戏性能的时候考虑渲染一帧所需要的毫秒数会更有用。有两个原因，首先这种一种更精准的测量方法。当我们尝试改善我们游戏性能的时候，每毫秒都能达到我们的目标。其次，帧率的相对变化意味着不同的规模帧率也是不一样的。从60FPS到50FPS代表处理时间增加了3.3毫秒，但是如果从30FPS到20FPS代表处理时间增加了16.6毫秒。同样是降低了10FPS，但是渲染一帧所花费的时间是截然不同的。\n了解普遍帧率渲染一帧所需要花费多少毫秒是非常有帮助的。要找到这个花费的时间，我们应该遵循这个公式1000/[渴望的帧率]。使用这个公式，我们可以知道每秒渲染30FPS，那么渲染每帧花费在33.3毫秒以内。一个游戏要运行到60FPS, 那么渲染每帧花费在16.6毫秒以内。\n对于渲染的每一帧，Unity都必须要执行很多不同的任务。简单来说，Unity必须更新游戏的状态，拿到游戏的快照并且渲染到屏幕。每帧必须要执行的任务包括读取用户输入、执行脚本、灯光运算。除此之外，还有一些一帧内执行多次的操作，如物理计算。当所有的任务执行的足够快，我们的游戏将会有一个一致性的，可接受的帧率。当所有的任务执行得不够快，会花费更长的时间去渲染，并且帧率会下降。\n知道哪个任务执行时间长，对如何解决游戏性能问题是至关重要的。一旦我们知道哪个任务在减低帧率，我们可以尝试优化那部分内容。这就是为什么分析如此重要：profiling工具可以显示在给定的帧在每个任务花费多长时间。\n记录分析数据 为了研究我们的游戏性能，我们必须记录游戏中性能不佳的数据。为了获得更加精准的分析数据，我们要打一个测试包运行在目标硬件上，并且记录分析数据。\n如果我们还不熟悉打包和真机记录分析数据，点击这里查看操作指南\n记录游戏数据   使用development build方式打包，在目标机上运行\n  在我们达到有性能问题之前，开始记录分析数据\n  一旦我们记录的分析数据包含了性能问题的例子，点击Profiler窗口上方任意位置以暂停游戏并选择一帧\n  在Profiler窗口的上方，选择显示性能较差的帧。这可能是低于我们要求帧率的“尖峰”或是有代表性的帧。我们可以使用左右按键或前进后退键在帧之间更好的移动。\n  我们已经获取游戏中性能较差的分析数据。下一步，让我们学习如何分析这些数据。\n分析数据 在得出任何关于游戏性能结论之前，我们必须学习如何阅读和分析显示在Profiler窗口的性能数据。我们知道，当Unity无法及时的完成渲染所需要的所有任务时，帧率会下降。我们将会使用Profiler窗口查看什么任务被执行了，任务花费多长时间以及按什么顺序执行的。这些信息会帮助会帮助我们明白我们游戏的哪些部分会造成任务花费太长的时间去渲染。\n最好去学习如何分析而不是学习一系列的步骤。自己理解这些数据更有用，这样当我们遇到了新问题的时候可以自己去研究。即使我们只是学会了在Unity解答上搜索，这也是一个伟大的开始。\n为了学习如何分析，我们将会使用CPU分析器作为例子，这可能是我们在研究帧率问题上用的最多的分析器。\nCPU分析器 当我们在Profiler窗口看CPU分析器的时候，我们可以看到CPU完成每帧所花费的时间。\n我们可以看到时间花费的彩色浪图。不同的颜色代表时间花在渲染操作上，物理计算上等等。那些关键字标明哪些颜色代表哪些任务。\n在接下来的截图中，我们可以到这一帧的主要时间花费在渲染操作上。下方的CPU时间指示器表明了我们的总的CPU时间在这一帧花费了85.95毫秒。\n层次结构图 让我们使用CPU分析器的层次结构视图去深挖当前数据并且更精确的查看当前帧哪一个任务花费CPU时间最多。当选中CPU分析器的时候，我们可以在Profiler窗口的下半屏看到当前帧的详细信息。查看Profiler窗口的下半屏，我们在做上方可以使用下拉菜单选择结构视图。这可以让我们看到CPU上正在发生的任务的详细信息。\n在层次结构图中，点击任何列的列头按该值排序。比如，点击Time ms按花费时间最长开始排序，点击Calls按当前高亮的帧调用次数最多的函数排序。在以上截图中，我们按照耗时排序，我们可以看到CPU最耗时的函数是Camera.Render。\n如果一个函数名字的左右有小箭头，我们可以展开看到这个函数调用了其他哪些函数和他们的性能影响。Self ms列表明这个函数自己的耗时，Time me列表明这个函数和它调用的其他函数的耗时。\n在这种情况下，我们可以看到Camera.Render下，最耗时的函数是Shadows.RenderJob。即使我们对这个具体的函数还不太了解，但是我们已经有关于我们游戏问题的信息了。我们知道我们的问题跟渲染有关，这个当前最耗时的任务是shaodws有关。\n我们可以在层次结构图做的另一个有用的事是比较我们游戏的帧，这样我们可以明白性能是如何随着时间的变化而变化的。我们使用CPU分析器一帧一帧的分析出单个最耗时的函数。当我们点击CPU分析器层级结构图上的函数名的时候，函数相关数据会高亮。\n比如，我们在层级结构视图点击Gfx.WaitForPresent，跟Gfx.WaitForPresent相关的渲染函数会高亮显示。\n时间线视图 现在让我们使用CPU分析器的时间视图学习更多关于我们渲染的问题。时间视图显示了两个东西：CPU任务执行的顺序和哪个线程负责哪个任务。我们可以在Profiler窗口的下半屏的左上角使用下拉按钮选择时间线视图（那里之前显示的是结构视图选项）\n线程可以同时运行多个单独任务。当一个线程执行任务的时，另一个线程可以执行完全独立的任务。Unity的渲染处理包含三种类型的线程：main thread、render thread和worker threads。了解哪些线程负责哪些任务是非常有帮助的：一旦我们知道了哪个线程执行了的任务最慢，我们就明白应该集中精力去优化那些线程的操作。\n我们可以放大时间线视图来更仔细的查看单个任务。被调用的函数也会在调用者下方立即显示出来。在这个例子中，我们已经放大了Shadows.RenderJob看到了组成这个任务的单个任务。我们可以看到Shadows.RenderJob是在main thread调用的。我们同样看到workder threads执行了跟shadows相关的任务。主线程列出了一个叫WaitingForJob的任务，表明main thread正在等待worker thread完成任务。从这我们可以得出结论，shadows相关的渲染操作在main thread和worker threads花费太长时间了。我们现在知道问题所在了。\n其他分析器 尽管在跟踪与帧率相关的性能问题时，CPU分析器是最常用的工具，其他分析器也同样非常有用。熟悉他们提供的信息是一个不错的主意。\n按照上面的步骤，尝试学习其他几个不同的分析器每帧提供了什么信息。比如，尝试使用渲染分析器，了解不同帧的渲染统计数据是如何变化的。\n确定造成性能问题的原因 既然我们熟悉了在分析器中读取和分析性能数据的过程，我可以开始找到造成性能问题的原因了。\n排除垂直同步 垂直同步简称VSync，用来匹配游戏帧率与屏幕刷新速度。垂直同步会影响游戏帧率，并且它的影响会显示在Profiler窗口上。如果我们不明确在看什么，还容易认为这是一个性能问题，所以在我们继续研究性能问题之前要学会如何排除掉垂直同步\n在CPU分析器中隐藏垂直同步信息 我们可以在CPU分析器中选择要隐藏的信息。这可以让我们忽略对当前研究没有帮助的信息。\n隐藏垂直同步的步骤如下：\n 点击CPU分析器 在Profiler窗口的顶部，CPU分析器区域显示当前关注的数据，点击标记为VSync的黄色正方形就可以隐藏垂直同步的信息  在层级结构视图中无视垂直同步信息 没有办法在层级结构视图中隐藏垂直同步信息，但我们知道了它长什么样子，我们就可以无视它。\n无论什么时候，我们在层级结构视图中看到WaitForTargetFPS，这意味着我们的游戏在等待垂直同步,我们不需要研究这个函数，忽略它就好。\n屏蔽垂直同步 垂直同步不能在所有的平台上都屏蔽：许多（如IOS）强制使用垂直同步。但如果我们正在为一个不需要强制使用垂直同步的平台开发，我们就可以屏蔽掉垂直同步。点击 Edit -\u0026gt; Project Settings -\u0026gt; Quality，找到VSync Count,下来菜单选中Don\u0026rsquo;t Sync\n渲染分析器 渲染是造成性能问题的常见原因。尝试修复渲染问题之前，确认我们的游戏是CPU密集还是GPU密集是很关键的，因为不同的情况，解决方法也不一样。\n简单的说，CPU负责决定绘制什么，而GPU负责绘制。如果渲染问题归咎于CPU耗时太多，那游戏就属于CPU密集，如果渲染问题归咎于GPU还是太多，那游戏就属于GPC密集。\n辨别我们的游戏是否是GPU密集 辨别我们的游戏是否是GPU密集最快捷的方法是使用GPU分析器。不幸的是，并不是所有的设备或驱动都支持这个分析器。在我们使用GPU分析器之前，我们先检测GPU分析器在目标设备上是否可用。\n检测GPU分析器在目标设备上是否可用，我们应该执行一下步骤：\n 在Profiler窗口左上角，选择Add profiler 通过下拉菜单选择GPU  如果GPU分析器不支持使用，我们会在GPU正常显示数据的区域看到一条以“GPU Profiling is not supported”开头的信息。\n如果没有没有看到这条信息，这意味着GPU分析器在目标设备上是支持的。如果GPU分析器是可用的，那执行一下步骤就能非常快速辨别出我们游戏是否是GPU密集：\n  点击GPU分析器\n  查看屏幕正中心区域，那里显示了当前选中帧的CPU和GPU耗时。\n如果GPU耗时大于CPU耗时，则我们可以确认我们的游戏是GPU密集。\n  如果GPU分析器不能在目标设备上使用，我们仍然可以辨别我们的游戏是否是GPU密集。我们可以通过观察CPU分析器。如果我们看到CPU正在等待GPU完成任务，这就是意味着我们游戏是GPU密集。为了查明是否存在这种情况，我们可以执行以下步骤：\n 点击选择CPU分析器 检查Profiler窗口底部区域显示的当前帧信息和分析器信息 在区域左上角的下拉菜单中选择层级结构视图 选择Time ms列头，函数耗时按时间排序  如果函数Gfx.WaitForPresent是CPU分析器中最好是的函数，这表明CPU正在等待GPU。这意味着我们的游戏是GPU密集。\n解决我们游戏是GPU密集时的渲染问题。\n如果我们已经确认我们的游戏是GPU密集，我们应该阅读这篇文章\n辨别我们的游戏是否是CPU密集 如果我们还没有确认造成性能问题的原因，现在我们研究基于CPU的渲染问题。\n 点击选择CPU分析器 随着时间的推移，Profiler窗口顶部信息会显示分析数据，检测图像中代表渲染的部分。我们可以通过点击关键字旁边的带颜色的正方形图片显示或隐藏这些数据。  如果慢帧的大部分时间被渲染占用了，这意味着渲染可能是造成我们问题的原因。我们可以按以下步骤继续挖掘来确认：\n 点击选择CPU分析器 检测Profiler窗口显示的当前帧信息和分析器信息 在分析数据区域左上角下拉菜单中选择层级结构 选择列头Time ms，按函数耗时排序 点击选择最顶部的函数  如果选中的是一个渲染函数，CPU分析器图像将会高亮显示Rendering图像。如果是这种情况，这意味着喧嚷相关的操作是造成我们性能问题的原因，也可以确认我们的游戏是CPU密集。留意函数名和是哪个线程执行这个函数。当我们尝试解决问题的时候，这些信息是很有用的。\n解决我们的游戏是CPU密集时的渲染问题。\n如果我们已经确认我们的游戏是CPU密集的渲染问题时，我们应该阅读这篇文章\n垃圾回收分析器 接下来，我们检查垃圾回收是否会造成瓶颈。垃圾回收是Unity自动内存管理的特性，这可能是一个缓慢的操作。\n  点击选择CPU分析器\n  注意，你可以拖拽你感兴趣的部分的名称，重新排序它们，在下面的截图中，我们拖拽GarbageCollector到顶部，并且点击关掉了其他方面的数据。\n如果慢帧的大部分时间被垃圾回收占用了，这指明了我们有垃圾回收过度的问题。我们可以深入研究以确认问题。\n  点击选择CPU分析器，检测Profiler窗口底部显示的当前帧相信信息\n  底部区域左上角下拉按钮选择层次结构视图\n  选择Time ms列头，以函数耗时排序\n  如果**GC.Collect()**函数出现，并且耗时比较多，我们就可以确认我们的游戏有垃圾回收问题。\n解决垃圾回收问题 如果我们确认我们的额游戏有垃圾回收问题，我们应该阅读这篇文章\n物理分析器 如果我们排除了渲染和垃圾会回收问题，我们检查负责的物理计算是否是造成我们性能问题的原因。\n 点击选择CPU分析器 在Profiler窗口显示数据的顶部，检测代表Physics的图像（橙色图像）。我们通过点击名字旁边的带颜色正方形来显示或隐藏图像。  如果慢帧的大部分时间被物理占用，那么可以确认武林是造成我们问题的原因。我们可以进一步研究以确认问题：\n 点击选中CPU分析器，检测Profiler下方区域显示的当前帧详细信息。 在底部区域左上角的下拉菜单选择层级结构视图 选择Time ms列头，按函数耗时排序 点击选择顶部的函数  如果选中的是一个物理函数，CPU分析器图像将会高亮显示Physics图像。如果是这种情况，我们可以确定造成性能问题的原因和物理计算相关。\n解决物理问题 如果我们确认我们的问题是物理引起，以下资料会有帮助：\n 文章 文章 文章  运行缓慢的脚本 现在我们检测缓慢的或过度负责的脚本是否是造成性能问题的原因。脚本，这里将的是非Unity引擎代码。这些脚本通常是我们自己写的，或者是第三方插件引入的。\n 点击选择CPU分析器 在Profiler窗口显示数据的顶部，检测代表Script的图像,我们可以通过点击关键字旁边的颜色方块显示或隐藏图像数据。  如果慢帧大部分时间被scripts占用，那可以确认开发者写的脚本是造成问题的原因。我们可以继续研究确认问题：\n 点击选中CPU分析器，检测Profiler窗口下方的当前帧详细数据 在底部区域左上角的下拉菜单选择层级结构视图 选择Time ms列头，按函数耗时排序 点击选择顶部的函数  如果是自己写的脚本，CPU分析器图像将会高亮显示Scripts图像。这种情况下，我们可以确认造成性能问题的原因与我们写的脚本有关。\n请注意，上面有一种特殊情况：当我们游戏包含渲染相关的函数，如Image Effects脚本或OnWillRenderObject或OnPreCull函数，这些将会出现在渲染分析器而不是脚本分析器。\n尽管起初有点小混乱，但是平常使用层级结构视图和时间线视图检测代码的时候，也能够跟踪到相关的代码。\n解决缓慢代码问题 如果我们确定自己写的脚本是造成性能问题的原因，这里有一些简单的技巧可以改善性能。下面是一个关于代码优化的资源：\n 文章 文章 文章  其他造成性能问题的原因 虽然我们已经讨论了性能问题最常见的四个原因，但是我们游戏可能有一些这里没有提到的性能问题。这种情况下，我们应该以上的一些方法来收集数据，研究CPU分析器并且找到造成问题的函数名字。一旦我们知道了函数名字，我们可以通过搜索Unity手册、Unity社区和Unity解答来或者这个函数的一些信息和如何减少这些函数消耗的方法。\n参考文章：\n使用Profiler进行性能分析\n","description":"","id":23,"section":"posts","tags":["Unity","Profiler"],"title":"【unity】使用Profiler进行性能分析","uri":"https://yichenlove.github.io/posts/unity-profiler/"},{"content":"目录  概述\n1.1 Vector3的定义\n1.2 主要优化的是什么？ xLua对Vector3的优化\n2.1 xLua创建Vector3\n2.2 xLua获取Vector3 \u0026ndash; C#的Vector3传入lua\n2.3 xLua 设置 Vector3到C#\n2.4 GCOptimize \u0026ndash; PushUnityEngineVector3的由来 toLua对Vector3的优化\n3.1 toLua创建Vector3\n3.2 toLua获取Vector3 \u0026ndash; C#的Vector3传入lua\n3.3 toLua 设置 Vector3到C# xLua与toLua对Vector3的优化的区别\n4.1 效率性能的比较\n4.2 扩展性的比较  一. 概述 1.1 Vector3的定义 public struct Vector3，是一个struct 结构体，值类型。\n1.2 主要优化的是什么？ 主要优化 减少gc + 减少lua与C#的交互。\n  为什么会产生gc？\n原因是boxing（装箱）和unboxing（拆箱）。Vector3（栈）转为object类型需要boxing（堆内存中），object转回Vector3需要unboxing，使用后释放该object引用，这个堆内存被gc检测到已经没引用，释放该堆内存，产生一个gc内存。\n  如何优化gc？\n值拷贝\n  二. xLua对Vector3的优化 2.1 xLua创建Vector3 lua中有2种方式可以表示Vector3：\n  创建Vector3对象，使用userdata：CS.UnityEngine.Vector3(7, 8, 9)\n  调用UnityEngineVector3Wrap中函数 static int __CreateInstance(RealStatePtr L)\n  C#中new一个Vector3： UnityEngine.Vector3 __cl_gen_ret = new UnityEngine.Vector3(x, y, z);\n  translator.PushUnityEngineVector3(L, __cl_gen_ret);\n要注意的是push方法是PushUnityEngineVector3，普通是translator.Push\n  xlua push vec3 to lua 2.png\nPushUnityEngineVector3做的优化是申请一块userdata（size=12），将Vector3拆成3个float，Pack到userdata，push到lua  xlua push float3 to lua 3.png\n这种Vector3 userdata传给C#后，有一个与Pack对应的UnPack 过程。    Table替代 : {x = 1, y = 2, z = 3}\n 创建时，不与Unity C#交互(这与toLua类似) 传给C#后，在C# UnPack 这个table，取出x、y、z， 赋值给new Vector3使用。 UnPack 在2.3中说明。    2.2 xLua获取Vector3 \u0026ndash; C#的Vector3传入lua lua中 aTransform.position获取Vector3坐标：\n UnityEngineTransformWrap. _g_get_position lua想从transform获取position  transform getposition.png\n获取C# transform对象：UnityEngine.Transform __cl_gen_to_be_invoked = (UnityEngine.Transform)translator.FastGetCSObj(L, 1); translator.PushUnityEngineVector3(L, __cl_gen_to_be_invoked.position); 这和2.1中创建一个Vector3 push userdata到lua过程一致。  2.3 xLua 设置 Vector3到C# lua中 aTransform.position = Vector3坐标：\n  UnityEngineTransformWrap. _s_set_position, lua想把pos设置到transform.position\nxLua transform setposition.png\n  设置position有2.1中的2种方式：\n 创建Vector3对象： aTransform.position = CS.UnityEngine.Vector3(7, 8, 9)  先获取userdata指针，再调用 CopyByValue.UnPack从指向内存的起始地址读取x，y，z值，设置到out UnityEngine.Vector3 field\nTable替代 : aTransform.position = {x = 1, y = 2, z = 3}\n直接调用 CopyByValue.UnPack，将Table的x，y，z值取出，设置到out UnityEngine.Vector3 val  transform setposition get.png\n  CopyByValue.UnPack\n上面2种方式调用的 CopyByValue.UnPack实现不同;\n userdata的方式，Pack的时候，使用xlua_pack_float3,对应的UnPack过程使用xlua_unpack_float3,解出userdata struct.\nxlua userdata方式设置vector3.png lua table,从栈中依次读取3个float值。  xlua table方式设置vector3.png\n  2.4 GCOptimize \u0026ndash; PushUnityEngineVector3的由来   为何Vector3的push到lua 会有一个针对优化的接口PushUnityEngineVector3？\nVector3 struct配置了GCOptimize属性（对于常用的UnityEngine的几个struct，Vector系列，Quaternion，Color。。。均已经配置了该属性），这个属性可以通过配置文件或者C# Attribute实现；\nGCOptimize Vector3.png\n  从GCOptimize列表中去掉Vector3 会怎么样呢？\nPushUnityEngineVector3接口就不存在了，而Vector3的push到lua会使用translator.Push(L, __cl_gen_ret); ，不做优化public void Push(RealStatePtr L, object o)，会产生boxing（装箱）和unboxing（拆箱），代表着一个gc。\n去掉vector3的GCOptimize后的push.png\n  三. toLua对Vector3的优化 toLua用lua重新实现了Vector3，包含所有方法；文件地址：tolua-master\\Assets\\ToLua\\Lua\\UnityEngine\\Vector3.lua\n3.1 toLua创建Vector3 1  Vector3.New(x, y, z)   toLua并没有跟Unity C#交互.\n3.2 toLua获取Vector3 \u0026ndash; C#的Vector3传入lua lua中 aTransform.position获取Vector3坐标：\n  C# UnityEngine_TransformWrap.get_position；调用ToLua.Push\ntoLua get_position.png\n  C#传入Vector3的x，y，z；\ntoLua get_position pushvec3.png\n  在lua建一个lua table，把x，y，z设置为对应字段；\n  设置该table的metatable为Vector3.lua的方法实现；\n  3.3 toLua 设置 Vector3到C#   从栈中取出对应table的x，y，z字段\ntoLua set_position ToVector3.png\n  C# new一个Vector3，将x，y，z赋值到Vector3；\n与xLua的table替代方式非常类似。\n  四. xLua与toLua对Vector3的优化的区别  效率性能的比较，toLua高  xLua与toLua都不产生gc xLua在创建Vector3的userdata方式和Vector3的方法调用，都需要跟Unity C#交互；而toLua在这两方面是纯Lua端执行，无需跟Unity C#交互，效率最高。 xLua有一个特点：所有无GC的类型，它的数组访问也没有GC。   扩展性的比较，xLua高\ntoLua重新Lua实现的类,需要增加一种新的值类型十分困难, 数量有限,并且与Unity C# Vector3核心代码深度耦合。  toLua lua类列表.png\nxLua支持的struct类型宽泛的多，包含枚举，用户要做的事情也很简单，用GCOptimize声明一下类型即可。支持自定义struct。（struct要求1.含无参构造函数 2.只包含值类型，可以嵌套其它只包含值类型的struct）\n相关链接  xlua github xlua特性 tolua 官网 tolua github Unity下XLua方案的各值类型GC优化深度剖析  参考文档\nhttps://www.jianshu.com/p/07dc38e85923\n","description":"","id":24,"section":"posts","tags":["Unity","xLua","toLua"],"title":"Unity中xLua与toLua对Vector3的优化","uri":"https://yichenlove.github.io/posts/unity-xlua-vector3/"},{"content":"LitJson解析JSON字符串空{}出错 问题\n1 2 3 4 5 6 7  string jsstr = \u0026#34;{\\\u0026#34;key1\\\u0026#34;:\\\u0026#34;value1\\\u0026#34;,\\\u0026#34;key2\\\u0026#34;:{},\\\u0026#34;key3\\\u0026#34;:\\\u0026#34;value3\\\u0026#34;}\u0026#34;; JsonData jsdata = JsonMapper.ToObject\u0026lt;JsonData\u0026gt;(jsstr); string outstr = JsonMapper.ToJson(jsddata); System.Console.WriteLine(\u0026#34;litjson json string:\u0026#34; + outstr); //输出litjson json string:{key1:value1,key2,key3:value3\u0026#34;}已不是一个正常的json字符串。   解决\n在JsonData.class的WriteJson方法最后添加一句writer.Write(null);即可解决。此方法也适用于解决空数组[]解析问题。\n参考 传送门：\n Incorrect json string on empty arrays  ","description":"","id":25,"section":"posts","tags":["LitJson","Unity"],"title":"Litjson Fix","uri":"https://yichenlove.github.io/posts/litjson-fix/"},{"content":"Hugo 完整使用教程 官网 基于go 语言开发\n官网地址：https://gohugo.io/\n环境 1.Homebrew\n如果你是macOS用户，请使用Homebrew快速安装\n2.Chocolatey\n如果你是windows用户，请使用Chocolatey快速安装\n 环境配置请参考本站对应安装教程\n 快速开始   安装 hugo\n1  brew install hugo     创建博客工程\n使用如下命令新建一个名为 mysite 的网站：\n1  hugo new site mysite     创建一片文章\n1  hugo new post/first.md     主题安装   下载主题\n官网主题地址：https://themes.gohugo.io/\n把主题通过git克隆或直接下载到本地。放到 …/blog/themes/目录下\n1 2  cd themes git clone https://github.com/vjeantet/hugo-theme-casper.git casper     编译预览\nhugo server -t casper -D 打开网址 http://localhost:1313/ 即可查看本地生成的静态网站\n  主题推荐\n bolg:https://github.com/dillonzq/LoveIt 预览 简约：\n* https://themes.gohugo.io//theme/hugo-theme-dimension/#\n* https://github.com/victoriadrake/hugo-theme-sam - 预览 个人简历：https://themes.gohugo.io/theme/hugo-uilite/ 网站：https://github.com/StefMa/hugo-fresh- 预览    参考文章  https://www.jianshu.com/p/4669fb3bf35a https://www.jianshu.com/p/0b9aecff290c  ","description":"","id":26,"section":"posts","tags":["hugo"],"title":"Use Hugo","uri":"https://yichenlove.github.io/posts/use-hugo/"},{"content":"Android Activity的Launch Mode 综述 对安卓而言，Activity有四种启动模式，它们是：\n standard 标准模式，每次都新建一个实例对象 singleTop 如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶 singleTask 如果在任务栈中发现了相同的实例，将其上面的任务终止并移除，重用该实例。否则新建实例并入栈 singleInstance 允许不同应用，进程线程等共用一个实例，无论从何应用调用该实例都重用  想要感受一下的话写一个小demo，然后自己启动自己再点返回键就看出来了。下面详细说说每一种启动模式\nstandard 一张图就很好理解\n什么配置都不写的话就是这种启动模式。但是每次都新建一个实例的话真是过于浪费，为了优化应该尽量考虑余下三种方式。\nsingleTop 每次扫描栈顶，如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶。\n配制方法实在Mainifest.xml中进行：\n\u0026lt;activity android:name=\u0026quot;.SingleTopActivity\u0026quot; android:label=\u0026quot;@string/singletop\u0026quot; android:launchMode=\u0026quot;singleTop\u0026quot; \u0026gt; \u0026lt;/activity\u0026gt; singleTask 与singleTop的区别是singleTask会扫描整个任务栈并制定策略。上效果图：\n使用时需要小心因为会将之前入栈的实例之上的实例全部移除，需要格外小心逻辑。\n配制方法：\n\u0026lt;activity android:name=\u0026quot;.SingleTopActivity\u0026quot; android:label=\u0026quot;@string/singletop\u0026quot; android:launchMode=\u0026quot;singleTop\u0026quot; \u0026gt; \u0026lt;/activity\u0026gt; singleInstance 这个的理解可以这么看：在微信里点击“用浏览器打开”一个朋友圈，然后切到QQ再用浏览器开一个网页，再跑到哪里再开一个页面。每次我们都在Activity中试图启动另一个浏览器Activity，但是在浏览器端看来，都是调用了同一个自己。因为使用了singleInstance模式，不同应用调用的Activity实际上是共享的。\n上说明图：\n配制方法：\n\u0026lt;activity android:name=\u0026quot;.SingleTopActivity\u0026quot; android:label=\u0026quot;@string/singletop\u0026quot; android:launchMode=\u0026quot;singleTop\u0026quot; \u0026gt; \u0026lt;/activity\u0026gt; 参考博客 传送门：\n Android Activity的Launch Mode  ","description":"","id":27,"section":"posts","tags":["android"],"title":"Android Activity的Launch Mode","uri":"https://yichenlove.github.io/posts/android-launchmode/"},{"content":"开始准备自己的博客，记录技术和记录生活。开始锻炼自己的写作，坚持动脑，记录点点滴滴。慢慢更新。慢慢积累。\n也可以当作自己的日记本，贵在坚持。\n2021-09-27国庆前终于使用hugo+zzo主题部署了一个自己个人博客主页。\n我的github主页 GitHub.\n","description":"自我介绍：并添加自己的相关吐槽","id":29,"section":"","tags":null,"title":"关于","uri":"https://yichenlove.github.io/about/"},{"content":"喜欢的二次元 pixiv\n","description":"cartoon gallery","id":30,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://yichenlove.github.io/gallery/cartoon/"}]